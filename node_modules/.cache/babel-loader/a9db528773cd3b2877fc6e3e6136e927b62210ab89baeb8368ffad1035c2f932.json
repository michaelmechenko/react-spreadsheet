{"ast":null,"code":"import { create, all } from \"mathjs\";\n\n// A cell in a spreadsheet that is an instance of the ICell interface\nexport class SpreadsheetCellModel {\n  constructor() {\n    // private isSelected: boolean;\n    // private textVisual: CellText;\n    this._buffer = void 0;\n    this._display = void 0;\n    this.dependencies = void 0;\n    this._buffer = \"\";\n    this._display = \"\";\n    // this.isSelected = false;\n    // Cells that depend on this cell\n    this.dependencies = new Set();\n    // this.textVisual = new CellText.Builder().build();\n  }\n\n  // Sets the buffer and display accordingly using the buffer and possible replacedBuffer inputs.\n  // buffer is the real buffer inputted by the user\n  // replacedBuffer is the buffer string with the replaced values which is needed to use mathjs\n  // Sets the buffer of this spreadsheet cell to be the new given buffer value\n  // If a replaceBuffer is given, it will evaluate the expression and set the\n  // display to be the result of that expression. Otherwise the display will\n  // match the buffer\n  setBuffer(buffer, replacedBuffer) {\n    this._buffer = buffer;\n    if (replacedBuffer !== undefined) {\n      try {\n        const math = create(all, {});\n        if (replacedBuffer.match(\"^[a-zA-Z][a-zA-Z0-9]*(\\\\+[a-zA-Z][a-zA-Z0-9]*)*$\")) {\n          let stringToConcatArr = replacedBuffer.split(\"+\");\n          this._display = stringToConcatArr.join(\"\");\n        } else {\n          this._display = String(math.evaluate(replacedBuffer));\n        }\n      } catch (error) {\n        console.warn(error);\n        this._display = \"!ERR\";\n      }\n    } else {\n      this._display = this._buffer;\n    }\n  }\n\n  // Returns the buffer value of this spreadsheet cell\n  getBuffer() {\n    return this._buffer;\n  }\n\n  // Returns the display value of this spreadsheet cell\n  getDisplay() {\n    return this._display;\n  }\n\n  // Return the dependencies of this spreadsheet cell\n  getDependencies() {\n    return Array.from(this.dependencies);\n  }\n\n  // Adds the given reference as a dependency to this spreadsheet cell\n  addDependency(r) {\n    this.dependencies.add(r);\n  }\n\n  // Removes the given reference from the dependencies of this spreadsheet cell\n  removeDependency(r) {\n    this.dependencies.delete(r);\n  }\n\n  // Shifts the dependencies of this cell up, left, down, or right depending on the inputs\n  shiftCellDependencies(down, right, rowIndex, colIndex) {\n    const newDependencies = new Set();\n    this.dependencies.forEach(dependency => {\n      // console.log('Shifting ' + dependency + ' down')\n      const rowCol = this.getRowColFromReference(dependency);\n      if (!(rowCol[0] === rowIndex && down < 0 || rowCol[1] === colIndex && right < 0)) {\n        if (rowCol[0] >= rowIndex && down > 0 || rowCol[0] > rowIndex && down < 0) {\n          rowCol[0] = rowCol[0] + down;\n        } else if (rowCol[1] >= colIndex && right > 0 || rowCol[1] > colIndex && right < 0) {\n          rowCol[1] = rowCol[1] + right;\n        }\n        const newReference = this.getColumnName(rowCol[1]) + (rowCol[0] + 1);\n        newDependencies.add(newReference);\n      }\n    });\n    this.dependencies = newDependencies;\n  }\n\n  // Parses a string reference to get the correct cell from spreadsheet page\n  getRowColFromReference(cellReference) {\n    // NEED TO CHECK THAT INPUT IS VALID\n    const colChar = cellReference.charAt(0).toUpperCase();\n    const col = colChar.charCodeAt(0) - \"A\".charCodeAt(0);\n    const row = parseInt(cellReference.substring(1)) - 1;\n    return [row, col];\n  }\n\n  // Get the character code for the column based on the given index\n  getColumnName(columnNumber) {\n    return String.fromCharCode(columnNumber + 65);\n  }\n\n  // Clears the buffer and display values for this spreadsheet cell\n  clearCell() {\n    this._buffer = \"\";\n    this._display = \"\";\n  }\n}","map":{"version":3,"names":["create","all","SpreadsheetCellModel","constructor","_buffer","_display","dependencies","Set","setBuffer","buffer","replacedBuffer","undefined","math","match","stringToConcatArr","split","join","String","evaluate","error","console","warn","getBuffer","getDisplay","getDependencies","Array","from","addDependency","r","add","removeDependency","delete","shiftCellDependencies","down","right","rowIndex","colIndex","newDependencies","forEach","dependency","rowCol","getRowColFromReference","newReference","getColumnName","cellReference","colChar","charAt","toUpperCase","col","charCodeAt","row","parseInt","substring","columnNumber","fromCharCode","clearCell"],"sources":["C:/Users/micha/Documents/mechenko_main/PEDAGOGY/fa23/CS4530/project/team111-project/implementation/src/model/domain/cells/spreadsheet-cell.model.ts"],"sourcesContent":["import { ICell } from \"../../interfaces/cell.interface\";\nimport { CellText } from \"./cell-text.model\";\nimport { create, all } from \"mathjs\";\n\n// A cell in a spreadsheet that is an instance of the ICell interface\nexport class SpreadsheetCellModel implements ICell {\n  // private isSelected: boolean;\n  // private textVisual: CellText;\n  private _buffer: string;\n  private _display: string;\n  private dependencies: Set<string>;\n\n  public constructor() {\n    this._buffer = \"\";\n    this._display = \"\";\n    // this.isSelected = false;\n    // Cells that depend on this cell\n    this.dependencies = new Set<string>();\n    // this.textVisual = new CellText.Builder().build();\n  }\n\n  // Sets the buffer and display accordingly using the buffer and possible replacedBuffer inputs.\n  // buffer is the real buffer inputted by the user\n  // replacedBuffer is the buffer string with the replaced values which is needed to use mathjs\n  // Sets the buffer of this spreadsheet cell to be the new given buffer value\n  // If a replaceBuffer is given, it will evaluate the expression and set the\n  // display to be the result of that expression. Otherwise the display will\n  // match the buffer\n  public setBuffer(buffer: string, replacedBuffer?: string): void {\n    this._buffer = buffer;\n\n    if (replacedBuffer !== undefined) {\n      try {\n        const math = create(all, {});\n        if (\n          replacedBuffer.match(\n            \"^[a-zA-Z][a-zA-Z0-9]*(\\\\+[a-zA-Z][a-zA-Z0-9]*)*$\"\n          )\n        ) {\n          let stringToConcatArr: string[] = replacedBuffer.split(\"+\");\n          this._display = stringToConcatArr.join(\"\");\n        } else {\n          this._display = String(math.evaluate(replacedBuffer));\n        }\n      } catch (error) {\n        console.warn(error);\n        this._display = \"!ERR\";\n      }\n    } else {\n      this._display = this._buffer;\n    }\n  }\n\n  // Returns the buffer value of this spreadsheet cell\n  public getBuffer(): string {\n    return this._buffer;\n  }\n\n  // Returns the display value of this spreadsheet cell\n  public getDisplay(): string {\n    return this._display;\n  }\n\n  // Return the dependencies of this spreadsheet cell\n  public getDependencies(): Array<string> {\n    return Array.from(this.dependencies);\n  }\n\n  // Adds the given reference as a dependency to this spreadsheet cell\n  public addDependency(r: string): void {\n    this.dependencies.add(r);\n  }\n\n  // Removes the given reference from the dependencies of this spreadsheet cell\n  public removeDependency(r: string): void {\n    this.dependencies.delete(r);\n  }\n\n  // Shifts the dependencies of this cell up, left, down, or right depending on the inputs\n  public shiftCellDependencies(\n    down: number,\n    right: number,\n    rowIndex: number,\n    colIndex: number\n  ) {\n    const newDependencies = new Set<string>();\n\n    this.dependencies.forEach((dependency) => {\n      // console.log('Shifting ' + dependency + ' down')\n      const rowCol = this.getRowColFromReference(dependency);\n\n      if (\n        !(\n          (rowCol[0] === rowIndex && down < 0) ||\n          (rowCol[1] === colIndex && right < 0)\n        )\n      ) {\n        if (\n          (rowCol[0] >= rowIndex && down > 0) ||\n          (rowCol[0] > rowIndex && down < 0)\n        ) {\n          rowCol[0] = rowCol[0] + down;\n        } else if (\n          (rowCol[1] >= colIndex && right > 0) ||\n          (rowCol[1] > colIndex && right < 0)\n        ) {\n          rowCol[1] = rowCol[1] + right;\n        }\n\n        const newReference = this.getColumnName(rowCol[1]) + (rowCol[0] + 1);\n\n        newDependencies.add(newReference);\n      }\n    });\n\n    this.dependencies = newDependencies;\n  }\n\n  // Parses a string reference to get the correct cell from spreadsheet page\n  private getRowColFromReference(cellReference: string): Array<number> {\n    // NEED TO CHECK THAT INPUT IS VALID\n    const colChar = cellReference.charAt(0).toUpperCase();\n    const col = colChar.charCodeAt(0) - \"A\".charCodeAt(0);\n    const row = parseInt(cellReference.substring(1)) - 1;\n\n    return [row, col];\n  }\n\n  // Get the character code for the column based on the given index\n  private getColumnName(columnNumber: number): string {\n    return String.fromCharCode(columnNumber + 65);\n  }\n\n  // Clears the buffer and display values for this spreadsheet cell\n  public clearCell(): void {\n    this._buffer = \"\";\n    this._display = \"\";\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}