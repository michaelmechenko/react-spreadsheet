{"ast":null,"code":"import { Expressions } from \"../../expressions/expression-enums.model\";\nimport { SpreadsheetCellModel } from \"./cells/spreadsheet-cell.model\";\n\n/**\n * Represents the Spreadsheet Page of the spreadsheet application.\n * Every page is first initialized as a 10x10 matrix\n */\n// Represents a page in the spreadsheet program with cells\nexport class SpreadSheetPageModel {\n  // private selectedCells: ICell[];\n\n  // Instanciates a spreadsheet page that defaults to a 15x15 page\n  // public constructor(name: string) {\n  constructor(name = \"\", rows = 15, cols = 15, data) {\n    this._sheetName = void 0;\n    this.sheet = void 0;\n    this._sheetName = name;\n    // this.selectedCells = [];\n    this.sheet = [];\n    for (let row = 0; row < rows; row++) {\n      this.sheet[row] = [];\n      for (let col = 0; col < cols; col++) {\n        if (data === undefined) {\n          this.sheet[row][col] = new SpreadsheetCellModel();\n        } else {\n          let cell = new SpreadsheetCellModel();\n          cell.setBuffer(data[row][col]);\n          this.sheet[row][col] = cell;\n        }\n      }\n    }\n  }\n\n  // Returns number of rows in spreadsheet page\n  getNumRows() {\n    return this.sheet.length;\n  }\n\n  // Returns number of columns in spreadsheet page\n  getNumCols() {\n    return this.sheet[0].length;\n  }\n\n  // Returns the name of this spreadsheet page\n  getSheetName() {\n    return this._sheetName;\n  }\n\n  // Sets the name of this spreadsheet to be the given name\n  setSheetName(newName) {\n    this._sheetName = newName;\n  }\n\n  // Gets the display value of a cell given the reference string\n\n  getValueAtCell(cellReference) {\n    const cell = this.getCellFromReference(cellReference);\n    return cell.getDisplay();\n  }\n\n  // Returns the buffer value of this cell\n  getCellValue(cellReference) {\n    const cell = this.getCellFromReference(cellReference);\n    return cell.getBuffer();\n  }\n\n  // sets the buffer of the given cell reference to the value\n  // does a check to see if the value is an expression which is indicated by '='\n  // Adds a dependency between the given cells\n  // Throws an error if a cycle would be created by the new dependency and does not add the dependency\n  addDependency(fromCell, toCell) {\n    if (this.validDependency(fromCell, toCell)) {\n      this.getCellFromReference(fromCell).addDependency(toCell);\n    } else {\n      throw new Error(\"Cycle Error\");\n    }\n  }\n\n  // Checks if a dependency between the given cells is valid\n  // A dependency is valid is no cycle is created by the dependency\n  validDependency(fromCell, toCell) {\n    if (this.getCellFromReference(toCell).getDependencies().includes(fromCell)) {\n      return false;\n    }\n    this.getCellFromReference(fromCell).getDependencies().forEach(dependency => {\n      return this.validDependency(dependency, toCell);\n    });\n    return true;\n  }\n\n  // Sets a new value to the referenced cell\n  setValue(cellReference, value) {\n    const cell = this.getCellFromReference(cellReference);\n    let expression = \"\";\n    if (value.startsWith(\"=\", 0)) {\n      try {\n        expression = this.evaluateExpression(cellReference, value.substring(1));\n        cell.setBuffer(value, expression);\n      } catch (error) {\n        throw new Error(`Invalid Expression ${error}`);\n      }\n    } else {\n      cell.setBuffer(value);\n    }\n    this.updateReferences(cell);\n  }\n\n  // Updates the cells that reference the given cell\n  updateReferences(cell) {\n    if (cell.getDependencies().length === 0) {\n      return;\n    } else {\n      cell.getDependencies().forEach(c => {\n        this.setValue(c, this.getCellValue(c));\n        const d = this.getCellFromReference(c);\n        this.updateReferences(d);\n      });\n    }\n  }\n\n  // private updateBuffersDown(index: number): void {\n  //     for (let row = 0; row < this.getNumRows(); row++) {\n  //         for (let col = 0; col < this.getNumCols(); col++) {\n  //             this.shiftBuffer(this.sheet[row][col], index, 1, 0, row, col);\n  //         }\n  //     }\n  // }\n\n  // private shiftBuffer(cell: ICell, index: number, down: number, right: number, rowIndex: number, colIndex: number): void {\n\n  //     let newBuffer = '';\n  //     const cellReference = this.getColumnName(colIndex) + (rowIndex+1);\n  //     const buff = cell.getBuffer();\n  //     if(buff.startsWith('=', 0)) {\n  //         try {\n  //             newBuffer = this.shiftBufferHelper(buff.substring(1));\n  //             this.setValue(cellReference, newBuffer);\n  //         } catch (error) {\n  //             throw new Error(`Invalid Expression ${error}`);\n  //         }\n  //     } else {\n  //         cell.setBuffer(buff);\n  //     }\n  // }\n\n  // private shiftBufferHelper(expression: string): string {\n  //     try {\n  //         while (expression.includes(Expressions.REF)) {\n  //             expression = this.\n  //         }\n  //     }\n  // }\n\n  // Parses a string reference to get the correct cell from spreadsheet page\n  // Returns the cell object given the cell reference\n  getCellFromReference(cellReference) {\n    const colArr = cellReference.match(/[A-Z]+/i);\n    const rowArr = cellReference.match(/\\d+/);\n    if (colArr == null || rowArr == null) {\n      throw new Error(\"Invalid row or col reference given\");\n    }\n    const colChars = colArr[0];\n    const rowChars = rowArr[0];\n    let col = this.getColumnIndex(colChars);\n    const row = parseInt(rowChars) - 1;\n    if (col > this.getNumCols() || row > this.getNumRows()) {\n      throw new Error(\"Reference out of bounds!\");\n    }\n    return this.sheet[row][col];\n  }\n\n  // Returns the cell at a given row and column\n  // Should be able to use getters and setters on the returned cell??\n  getCellAtRowCol(row, col) {\n    return this.sheet[row][col];\n  }\n\n  // Adds a row to the spreadsheet page below the given row index\n  addRow(index) {\n    if (index < 0 || index > this.sheet.length) {\n      throw new Error(\"Invalid row index\");\n    }\n    const newRow = [];\n    for (let col = 0; col < this.sheet[0].length; col++) {\n      newRow[col] = new SpreadsheetCellModel();\n    }\n    this.sheet.splice(index, 0, newRow);\n    this.shiftDependenciesDown(index);\n\n    // Adjust buffers (ew)\n  }\n\n  // shifts all dependencies within the spreadsheet down that are affected\n  // by adding a row at the given index\n  shiftDependenciesDown(index) {\n    for (let row = 0; row < this.getNumRows(); row++) {\n      for (let col = 0; col < this.getNumCols(); col++) {\n        // if this.sheet[row][col].getBuffer() has a cell reference (A2) whose row value (2) is greater than index,\n        // do this.sheet[row][col].setBuffer(the updated buffer with A3 instead of A2)\n        const currentBuffer = this.sheet[row][col].getBuffer();\n\n        // Regular expression to match cell references like \"AA2\" or \"AA18\"\n        const cellReferenceRegex = /[A-Z]+[0-9]+/g;\n\n        // Check if currentBuffer contains any cell references\n        const matches = currentBuffer.match(cellReferenceRegex);\n        if (matches) {\n          // Update the buffer for each matching cell reference\n          matches.forEach(cellReference => {\n            const [colChars, rowStr] = cellReference.match(/[A-Z]+|\\d+/g) || [];\n            const cellRow = parseInt(rowStr) || 0;\n            if (cellRow > index) {\n              // Replace the row value in the cell reference with (cellRow + 1)\n              const updatedBuffer = currentBuffer.replace(cellReference, `${colChars}${cellRow + 1}`);\n              this.sheet[row][col].setBuffer(updatedBuffer);\n              this.setValue(`${this.getColumnName(col)}${row + 1}`, updatedBuffer);\n            }\n          });\n        }\n        this.sheet[row][col].shiftCellDependencies(1, 0, index, -1);\n      }\n    }\n  }\n\n  // TODO: ADD BUFFER CHANGE WHEN ROW IS DELETED\n  // shifts all dependencies within the spreadsheet up that are\n  // affected by removing a row at the given index\n  shiftDependenciesUp(index) {\n    for (let row = 0; row < this.getNumRows(); row++) {\n      for (let col = 0; col < this.getNumCols(); col++) {\n        this.sheet[row][col].shiftCellDependencies(-1, 0, index, -1);\n      }\n    }\n  }\n\n  // shifts right all dependencies within the spreadsheet page that are affected\n  // by adding a column at the given index\n  shiftDependenciesRight(index) {\n    for (let row = 0; row < this.getNumRows(); row++) {\n      for (let col = 0; col < this.getNumCols(); col++) {\n        // if this.sheet[row][col].getBuffer() has a cell reference (A2) whose row value (2) is greater than index,\n        // do this.sheet[row][col].setBuffer(the updated buffer with A3 instead of A2)\n        const currentBuffer = this.sheet[row][col].getBuffer();\n\n        // Regular expression to match cell references like \"AA2\" or \"AA18\"\n        const cellReferenceRegex = /[A-Z]+[0-9]+/g;\n\n        // Check if currentBuffer contains any cell references\n        const matches = currentBuffer.match(cellReferenceRegex);\n        if (matches) {\n          // Update the buffer for each matching cell reference\n          matches.forEach(cellReference => {\n            const [colChars, rowStr] = cellReference.match(/[A-Z]+|\\d+/g) || [];\n            const cellRow = parseInt(rowStr) || 0;\n            const colIndex = this.getColumnIndex(colChars);\n            if (cellRow > index) {\n              // Replace the row value in the cell reference with (cellRow + 1)\n              const updatedBuffer = currentBuffer.replace(cellReference, `${this.getColumnName(colIndex + 1)}${cellRow}`);\n              this.setValue(`${this.getColumnName(col + 1)}${row}`, updatedBuffer);\n            }\n          });\n        }\n        this.sheet[row][col].shiftCellDependencies(0, 1, -1, index);\n      }\n    }\n  }\n\n  // TODO: ADD BUFFER CHANGE WHEN COL IS DELETED\n  // shifts left all dependencies within the spreadsheet page that are\n  // affected by removing a column at the given index\n  shiftDependenciesLeft(index) {\n    for (let row = 0; row < this.getNumRows(); row++) {\n      for (let col = 0; col < this.getNumCols(); col++) {\n        this.sheet[row][col].shiftCellDependencies(0, -1, -1, index);\n      }\n    }\n  }\n\n  // Adds a column to the spreadsheet page to the right of the given column index\n  addColumn(index) {\n    if (index < 0 || index > this.sheet[0].length) {\n      throw new Error(\"Invalid column index\");\n    }\n    for (let row = 0; row < this.sheet.length; row++) {\n      this.sheet[row].splice(index, 0, new SpreadsheetCellModel());\n    }\n    this.shiftDependenciesRight(index);\n\n    // Adjust buffers (ew)\n  }\n\n  // Removes the row of the spreadsheet page at the given row index\n  removeRow(index) {\n    if (index < 0 || index >= this.sheet.length) {\n      throw new Error(\"Invalid row index\");\n    }\n    this.sheet.splice(index, 1);\n    this.shiftDependenciesUp(index);\n\n    // Adjust buffers (ew)\n  }\n\n  // Removes the column of the spreadsheet page at the given column index\n  removeColumn(index) {\n    if (index < 0 || index >= this.sheet[0].length) {\n      throw new Error(\"Invalid column index\");\n    }\n    for (let row = 0; row < this.sheet.length; row++) {\n      this.sheet[row].splice(index, 1);\n    }\n    this.shiftDependenciesLeft(index);\n\n    // Adjust buffers (ew)\n  }\n\n  // Replaces the range or reference function if found in the expression with the actual number\n  // Evaluates the given reference expression at the given originCell\n  evaluateExpression(originCell, input) {\n    try {\n      while (input.includes(Expressions.REF)) {\n        input = this.evaluateRefExpressions(originCell, input);\n      }\n      while (input.includes(Expressions.SUM)) {\n        input = this.evaluateSumExpressions(originCell, input);\n      }\n      while (input.includes(Expressions.AVG)) {\n        input = this.evaluateAvgExpressions(originCell, input);\n      }\n      return input;\n    } catch (error) {\n      throw new Error(`Failed to replace expressions ${error}`);\n    }\n  }\n\n  // replaces any 'REF(x)' found using regex with the correct cell display\n  // Parses through the reference expression, adding a dependency and reformatting\n  // the expression to be evaluated\n  evaluateRefExpressions(originCell, input) {\n    const refRegex = /REF\\(([^)]+)\\)/g;\n    return input.replace(refRegex, (_, cellReference) => {\n      this.addDependency(cellReference, originCell);\n      return this.getCellFromReference(cellReference).getDisplay();\n    });\n  }\n\n  // replaces any 'SUM(A1:A3)' found using regex with the correct sum\n  // Parses through the sum expression,\n  // reformatting the expression to be evaluated\n  evaluateSumExpressions(originCell, input) {\n    const sumRegex = /SUM\\(([^)]+)\\)/g;\n    return input.replace(sumRegex, (_, range) => this.sumCells(originCell, range));\n  }\n\n  // replaces any 'AVG(A1:A3)' found using regex with the correct average\n  // Parses through the average expression,\n  // reformatting the expression to be evaluated\n  evaluateAvgExpressions(originCell, input) {\n    const avgRegex = /AVG\\(([^)]+)\\)/g;\n    return input.replace(avgRegex, (_, range) => this.averageCells(originCell, range));\n  }\n\n  // Finds all cells that was given in the range and returns the sum of all cell values\n\n  // Evaluates the sum of a range or group of cells\n\n  sumCells(originCell, range) {\n    let sum = 0;\n    let cellRange = [];\n    if (range.match(\"^[^:]+:[^:]+$\")) {\n      // regex to match expressions using colon for cell range\n      const [startCell, endCell] = range.split(\":\");\n      cellRange = this.getRangeOfCells(startCell, endCell);\n    } else if (range.match(\"^[A-Za-z]\\\\d+(,\\\\s?[A-Za-z]\\\\d+)*$\")) {\n      // regex to match expressions using comma\n      cellRange = range.split(\",\");\n    } else {\n      throw new Error(`Syntax for reference is not correct. ${range}`);\n    }\n    for (let cell of cellRange) {\n      this.addDependency(cell, originCell);\n      let cellVal = Number(this.getCellFromReference(cell).getDisplay());\n      if (Number.isNaN(cellVal)) {\n        throw new Error(\"Cell is not a Number\");\n      } else {\n        sum += cellVal;\n      }\n    }\n    return sum.toString();\n  }\n\n  // Finds all cells that was given in the range and returns the average of all cell values\n  // Evaluates the average of a range or group of cells\n  averageCells(originCell, range) {\n    let sum = 0;\n    let cellRange = [];\n    if (range.match(\"^[^:]+:[^:]+$\")) {\n      // regex to match expressions using colon for cell range\n      const [startCell, endCell] = range.split(\":\");\n      cellRange = this.getRangeOfCells(startCell, endCell);\n    } else if (range.match(\"^[A-Za-z]\\\\d+(,\\\\s?[A-Za-z]\\\\d+)*$\")) {\n      // regex to match expressions using comma\n      cellRange = range.split(\",\");\n    } else {\n      throw new Error(`Syntax for reference is not correct. ${range}`);\n    }\n    let count = cellRange.length;\n    for (let cell of cellRange) {\n      this.addDependency(cell, originCell);\n      let cellVal = Number(this.getCellFromReference(cell).getDisplay());\n      if (Number.isNaN(cellVal)) {\n        throw new Error(\"Cell is not a Number\");\n      } else {\n        sum += cellVal;\n      }\n    }\n    let average = sum / count;\n    return average.toString();\n  }\n\n  // Returns a list of cells that contains all cells that are represented by a range of cells (A1, C2)\n\n  // Gets all the cells within a range given the start and end of the range\n  getRangeOfCells(startCell, endCell) {\n    let cells = [];\n    const startCol = startCell.match(/[A-Z]+/i)[0];\n    const startRow = startCell.match(/\\d+/)[0];\n    const endCol = endCell.match(/[A-Z]+/i)[0];\n    const endRow = endCell.match(/\\d+/)[0];\n    let startColIdx = this.getColumnIndex(startCol);\n    let endColIdx = this.getColumnIndex(endCol);\n    const startRowIdx = parseInt(startRow);\n    const endRowIdx = parseInt(endRow);\n    for (let i = startRowIdx; i <= endRowIdx; i++) {\n      for (let j = startColIdx; j <= endColIdx; j++) {\n        cells.push(this.getColumnName(j) + i);\n      }\n    }\n    return cells;\n  }\n\n  // returns the column name (uppercase alphabetical) given the column index\n  // Gets the character code for a column given the index\n  getColumnName(columnNumber) {\n    let columnName = \"\";\n    while (columnNumber >= 0) {\n      columnName = String.fromCharCode(columnNumber % 26 + 65) + columnName;\n      columnNumber = Math.floor(columnNumber / 26) - 1;\n    }\n    return columnName;\n  }\n\n  // returns the column index given the column name (uppercase alphabetical)\n  getColumnIndex(column) {\n    let colIndex = -1;\n    for (let i = 0; i < column.length; i++) {\n      colIndex += (column[i].charCodeAt(0) - \"A\".charCodeAt(0) + 1) * Math.pow(26, column.length - i - 1);\n    }\n    return colIndex;\n  }\n}","map":{"version":3,"names":["Expressions","SpreadsheetCellModel","SpreadSheetPageModel","constructor","name","rows","cols","data","_sheetName","sheet","row","col","undefined","cell","setBuffer","getNumRows","length","getNumCols","getSheetName","setSheetName","newName","getValueAtCell","cellReference","getCellFromReference","getDisplay","getCellValue","getBuffer","addDependency","fromCell","toCell","validDependency","Error","getDependencies","includes","forEach","dependency","setValue","value","expression","startsWith","evaluateExpression","substring","error","updateReferences","c","d","colArr","match","rowArr","colChars","rowChars","getColumnIndex","parseInt","getCellAtRowCol","addRow","index","newRow","splice","shiftDependenciesDown","currentBuffer","cellReferenceRegex","matches","rowStr","cellRow","updatedBuffer","replace","getColumnName","shiftCellDependencies","shiftDependenciesUp","shiftDependenciesRight","colIndex","shiftDependenciesLeft","addColumn","removeRow","removeColumn","originCell","input","REF","evaluateRefExpressions","SUM","evaluateSumExpressions","AVG","evaluateAvgExpressions","refRegex","_","sumRegex","range","sumCells","avgRegex","averageCells","sum","cellRange","startCell","endCell","split","getRangeOfCells","cellVal","Number","isNaN","toString","count","average","cells","startCol","startRow","endCol","endRow","startColIdx","endColIdx","startRowIdx","endRowIdx","i","j","push","columnNumber","columnName","String","fromCharCode","Math","floor","column","charCodeAt","pow"],"sources":["C:/Users/micha/Documents/mechenko_main/PEDAGOGY/fa23/CS4530/project/team111-project/implementation/src/model/domain/spreadsheet-page.model.ts"],"sourcesContent":["import { Expressions } from \"../../expressions/expression-enums.model\";\nimport { ICell } from \"../interfaces/cell.interface\";\nimport { ISpreadsheetPage } from \"../interfaces/spreadsheet-page.interface\";\nimport { SpreadsheetCellModel } from \"./cells/spreadsheet-cell.model\";\n\n/**\n * Represents the Spreadsheet Page of the spreadsheet application.\n * Every page is first initialized as a 10x10 matrix\n */\n// Represents a page in the spreadsheet program with cells\nexport class SpreadSheetPageModel implements ISpreadsheetPage {\n  private _sheetName: string;\n  private sheet: SpreadsheetCellModel[][];\n  // private selectedCells: ICell[];\n\n  // Instanciates a spreadsheet page that defaults to a 15x15 page\n  // public constructor(name: string) {\n  public constructor(\n    name: string = \"\",\n    rows: number = 15,\n    cols: number = 15,\n    data?: string[][]\n  ) {\n    this._sheetName = name;\n    // this.selectedCells = [];\n    this.sheet = [];\n\n    for (let row: number = 0; row < rows; row++) {\n      this.sheet[row] = [];\n      for (let col: number = 0; col < cols; col++) {\n        if (data === undefined) {\n          this.sheet[row][col] = new SpreadsheetCellModel();\n        } else {\n          let cell: SpreadsheetCellModel = new SpreadsheetCellModel();\n          cell.setBuffer(data[row][col]);\n          this.sheet[row][col] = cell;\n        }\n      }\n    }\n  }\n\n  // Returns number of rows in spreadsheet page\n  public getNumRows(): number {\n    return this.sheet.length;\n  }\n\n  // Returns number of columns in spreadsheet page\n  public getNumCols(): number {\n    return this.sheet[0].length;\n  }\n\n  // Returns the name of this spreadsheet page\n  public getSheetName(): string {\n    return this._sheetName;\n  }\n\n  // Sets the name of this spreadsheet to be the given name\n  public setSheetName(newName: string) {\n    this._sheetName = newName;\n  }\n\n  // Gets the display value of a cell given the reference string\n\n  public getValueAtCell(cellReference: string): string {\n    const cell = this.getCellFromReference(cellReference);\n    return cell.getDisplay();\n  }\n\n  // Returns the buffer value of this cell\n  private getCellValue(cellReference: string): string {\n    const cell = this.getCellFromReference(cellReference);\n    return cell.getBuffer();\n  }\n\n  // sets the buffer of the given cell reference to the value\n  // does a check to see if the value is an expression which is indicated by '='\n  // Adds a dependency between the given cells\n  // Throws an error if a cycle would be created by the new dependency and does not add the dependency\n  private addDependency(fromCell: string, toCell: string): void {\n    if (this.validDependency(fromCell, toCell)) {\n      this.getCellFromReference(fromCell).addDependency(toCell);\n    } else {\n      throw new Error(\"Cycle Error\");\n    }\n  }\n\n  // Checks if a dependency between the given cells is valid\n  // A dependency is valid is no cycle is created by the dependency\n  private validDependency(fromCell: string, toCell: string) {\n    if (\n      this.getCellFromReference(toCell).getDependencies().includes(fromCell)\n    ) {\n      return false;\n    }\n    this.getCellFromReference(fromCell)\n      .getDependencies()\n      .forEach((dependency) => {\n        return this.validDependency(dependency, toCell);\n      });\n\n    return true;\n  }\n\n  // Sets a new value to the referenced cell\n  public setValue(cellReference: string, value: string): void {\n    const cell = this.getCellFromReference(cellReference);\n    let expression = \"\";\n    if (value.startsWith(\"=\", 0)) {\n      try {\n        expression = this.evaluateExpression(cellReference, value.substring(1));\n        cell.setBuffer(value, expression);\n      } catch (error) {\n        throw new Error(`Invalid Expression ${error}`);\n      }\n    } else {\n      cell.setBuffer(value);\n    }\n\n    this.updateReferences(cell);\n  }\n\n  // Updates the cells that reference the given cell\n  private updateReferences(cell: ICell): void {\n    if (cell.getDependencies().length === 0) {\n      return;\n    } else {\n      cell.getDependencies().forEach((c) => {\n        this.setValue(c, this.getCellValue(c));\n        const d = this.getCellFromReference(c);\n        this.updateReferences(d);\n      });\n    }\n  }\n\n  // private updateBuffersDown(index: number): void {\n  //     for (let row = 0; row < this.getNumRows(); row++) {\n  //         for (let col = 0; col < this.getNumCols(); col++) {\n  //             this.shiftBuffer(this.sheet[row][col], index, 1, 0, row, col);\n  //         }\n  //     }\n  // }\n\n  // private shiftBuffer(cell: ICell, index: number, down: number, right: number, rowIndex: number, colIndex: number): void {\n\n  //     let newBuffer = '';\n  //     const cellReference = this.getColumnName(colIndex) + (rowIndex+1);\n  //     const buff = cell.getBuffer();\n  //     if(buff.startsWith('=', 0)) {\n  //         try {\n  //             newBuffer = this.shiftBufferHelper(buff.substring(1));\n  //             this.setValue(cellReference, newBuffer);\n  //         } catch (error) {\n  //             throw new Error(`Invalid Expression ${error}`);\n  //         }\n  //     } else {\n  //         cell.setBuffer(buff);\n  //     }\n  // }\n\n  // private shiftBufferHelper(expression: string): string {\n  //     try {\n  //         while (expression.includes(Expressions.REF)) {\n  //             expression = this.\n  //         }\n  //     }\n  // }\n\n  // Parses a string reference to get the correct cell from spreadsheet page\n  // Returns the cell object given the cell reference\n  public getCellFromReference(cellReference: string): SpreadsheetCellModel {\n    const colArr = cellReference.match(/[A-Z]+/i);\n    const rowArr = cellReference.match(/\\d+/);\n\n    if (colArr == null || rowArr == null) {\n      throw new Error(\"Invalid row or col reference given\");\n    }\n    const colChars = colArr[0];\n    const rowChars = rowArr[0];\n    let col = this.getColumnIndex(colChars);\n\n    const row = parseInt(rowChars) - 1;\n\n    if (col > this.getNumCols() || row > this.getNumRows()) {\n      throw new Error(\"Reference out of bounds!\");\n    }\n\n    return this.sheet[row][col];\n  }\n\n  // Returns the cell at a given row and column\n  // Should be able to use getters and setters on the returned cell??\n  public getCellAtRowCol(row: number, col: number): SpreadsheetCellModel {\n    return this.sheet[row][col];\n  }\n\n  // Adds a row to the spreadsheet page below the given row index\n  public addRow(index: number): void {\n    if (index < 0 || index > this.sheet.length) {\n      throw new Error(\"Invalid row index\");\n    }\n\n    const newRow: SpreadsheetCellModel[] = [];\n    for (let col = 0; col < this.sheet[0].length; col++) {\n      newRow[col] = new SpreadsheetCellModel();\n    }\n\n    this.sheet.splice(index, 0, newRow);\n\n    this.shiftDependenciesDown(index);\n\n    // Adjust buffers (ew)\n  }\n\n  // shifts all dependencies within the spreadsheet down that are affected\n  // by adding a row at the given index\n  private shiftDependenciesDown(index: number) {\n    for (let row = 0; row < this.getNumRows(); row++) {\n      for (let col = 0; col < this.getNumCols(); col++) {\n        // if this.sheet[row][col].getBuffer() has a cell reference (A2) whose row value (2) is greater than index,\n        // do this.sheet[row][col].setBuffer(the updated buffer with A3 instead of A2)\n        const currentBuffer = this.sheet[row][col].getBuffer();\n\n        // Regular expression to match cell references like \"AA2\" or \"AA18\"\n        const cellReferenceRegex = /[A-Z]+[0-9]+/g;\n\n        // Check if currentBuffer contains any cell references\n        const matches = currentBuffer.match(cellReferenceRegex);\n\n        if (matches) {\n          // Update the buffer for each matching cell reference\n          matches.forEach((cellReference) => {\n            const [colChars, rowStr] = cellReference.match(/[A-Z]+|\\d+/g) || [];\n            const cellRow = parseInt(rowStr) || 0;\n\n            if (cellRow > index) {\n              // Replace the row value in the cell reference with (cellRow + 1)\n              const updatedBuffer = currentBuffer.replace(\n                cellReference,\n                `${colChars}${cellRow + 1}`\n              );\n              this.sheet[row][col].setBuffer(updatedBuffer);\n              this.setValue(\n                `${this.getColumnName(col)}${row + 1}`,\n                updatedBuffer\n              );\n            }\n          });\n        }\n\n        this.sheet[row][col].shiftCellDependencies(1, 0, index, -1);\n      }\n    }\n  }\n\n  // TODO: ADD BUFFER CHANGE WHEN ROW IS DELETED\n  // shifts all dependencies within the spreadsheet up that are\n  // affected by removing a row at the given index\n  private shiftDependenciesUp(index: number) {\n    for (let row = 0; row < this.getNumRows(); row++) {\n      for (let col = 0; col < this.getNumCols(); col++) {\n        this.sheet[row][col].shiftCellDependencies(-1, 0, index, -1);\n      }\n    }\n  }\n\n  // shifts right all dependencies within the spreadsheet page that are affected\n  // by adding a column at the given index\n  private shiftDependenciesRight(index: number) {\n    for (let row = 0; row < this.getNumRows(); row++) {\n      for (let col = 0; col < this.getNumCols(); col++) {\n        // if this.sheet[row][col].getBuffer() has a cell reference (A2) whose row value (2) is greater than index,\n        // do this.sheet[row][col].setBuffer(the updated buffer with A3 instead of A2)\n        const currentBuffer = this.sheet[row][col].getBuffer();\n\n        // Regular expression to match cell references like \"AA2\" or \"AA18\"\n        const cellReferenceRegex = /[A-Z]+[0-9]+/g;\n\n        // Check if currentBuffer contains any cell references\n        const matches = currentBuffer.match(cellReferenceRegex);\n\n        if (matches) {\n          // Update the buffer for each matching cell reference\n          matches.forEach((cellReference) => {\n            const [colChars, rowStr] = cellReference.match(/[A-Z]+|\\d+/g) || [];\n\n            const cellRow = parseInt(rowStr) || 0;\n            const colIndex = this.getColumnIndex(colChars!);\n\n            if (cellRow > index) {\n              // Replace the row value in the cell reference with (cellRow + 1)\n              const updatedBuffer = currentBuffer.replace(\n                cellReference,\n                `${this.getColumnName(colIndex + 1)}${cellRow}`\n              );\n              this.setValue(\n                `${this.getColumnName(col + 1)}${row}`,\n                updatedBuffer\n              );\n            }\n          });\n        }\n\n        this.sheet[row][col].shiftCellDependencies(0, 1, -1, index);\n      }\n    }\n  }\n\n  // TODO: ADD BUFFER CHANGE WHEN COL IS DELETED\n  // shifts left all dependencies within the spreadsheet page that are\n  // affected by removing a column at the given index\n  private shiftDependenciesLeft(index: number) {\n    for (let row = 0; row < this.getNumRows(); row++) {\n      for (let col = 0; col < this.getNumCols(); col++) {\n        this.sheet[row][col].shiftCellDependencies(0, -1, -1, index);\n      }\n    }\n  }\n\n  // Adds a column to the spreadsheet page to the right of the given column index\n  public addColumn(index: number): void {\n    if (index < 0 || index > this.sheet[0].length) {\n      throw new Error(\"Invalid column index\");\n    }\n\n    for (let row = 0; row < this.sheet.length; row++) {\n      this.sheet[row].splice(index, 0, new SpreadsheetCellModel());\n    }\n\n    this.shiftDependenciesRight(index);\n\n    // Adjust buffers (ew)\n  }\n\n  // Removes the row of the spreadsheet page at the given row index\n  public removeRow(index: number): void {\n    if (index < 0 || index >= this.sheet.length) {\n      throw new Error(\"Invalid row index\");\n    }\n\n    this.sheet.splice(index, 1);\n\n    this.shiftDependenciesUp(index);\n\n    // Adjust buffers (ew)\n  }\n\n  // Removes the column of the spreadsheet page at the given column index\n  public removeColumn(index: number): void {\n    if (index < 0 || index >= this.sheet[0].length) {\n      throw new Error(\"Invalid column index\");\n    }\n\n    for (let row = 0; row < this.sheet.length; row++) {\n      this.sheet[row].splice(index, 1);\n    }\n\n    this.shiftDependenciesLeft(index);\n\n    // Adjust buffers (ew)\n  }\n\n  // Replaces the range or reference function if found in the expression with the actual number\n  // Evaluates the given reference expression at the given originCell\n  private evaluateExpression(originCell: string, input: string): string {\n    try {\n      while (input.includes(Expressions.REF)) {\n        input = this.evaluateRefExpressions(originCell, input);\n      }\n\n      while (input.includes(Expressions.SUM)) {\n        input = this.evaluateSumExpressions(originCell, input);\n      }\n\n      while (input.includes(Expressions.AVG)) {\n        input = this.evaluateAvgExpressions(originCell, input);\n      }\n\n      return input;\n    } catch (error) {\n      throw new Error(`Failed to replace expressions ${error}`);\n    }\n  }\n\n  // replaces any 'REF(x)' found using regex with the correct cell display\n  // Parses through the reference expression, adding a dependency and reformatting\n  // the expression to be evaluated\n  private evaluateRefExpressions(originCell: string, input: string): string {\n    const refRegex = /REF\\(([^)]+)\\)/g;\n    return input.replace(refRegex, (_, cellReference) => {\n      this.addDependency(cellReference, originCell);\n      return this.getCellFromReference(cellReference).getDisplay();\n    });\n  }\n\n  // replaces any 'SUM(A1:A3)' found using regex with the correct sum\n  // Parses through the sum expression,\n  // reformatting the expression to be evaluated\n  private evaluateSumExpressions(originCell: string, input: string): string {\n    const sumRegex = /SUM\\(([^)]+)\\)/g;\n    return input.replace(sumRegex, (_, range) =>\n      this.sumCells(originCell, range)\n    );\n  }\n\n  // replaces any 'AVG(A1:A3)' found using regex with the correct average\n  // Parses through the average expression,\n  // reformatting the expression to be evaluated\n  private evaluateAvgExpressions(originCell: string, input: string): string {\n    const avgRegex = /AVG\\(([^)]+)\\)/g;\n    return input.replace(avgRegex, (_, range) =>\n      this.averageCells(originCell, range)\n    );\n  }\n\n  // Finds all cells that was given in the range and returns the sum of all cell values\n\n  // Evaluates the sum of a range or group of cells\n\n  private sumCells(originCell: string, range: string): string {\n    let sum: number = 0;\n    let cellRange: string[] = [];\n\n    if (range.match(\"^[^:]+:[^:]+$\")) {\n      // regex to match expressions using colon for cell range\n      const [startCell, endCell] = range.split(\":\");\n      cellRange = this.getRangeOfCells(startCell, endCell);\n    } else if (range.match(\"^[A-Za-z]\\\\d+(,\\\\s?[A-Za-z]\\\\d+)*$\")) {\n      // regex to match expressions using comma\n      cellRange = range.split(\",\");\n    } else {\n      throw new Error(`Syntax for reference is not correct. ${range}`);\n    }\n\n    for (let cell of cellRange) {\n      this.addDependency(cell, originCell);\n\n      let cellVal = Number(this.getCellFromReference(cell).getDisplay());\n      if (Number.isNaN(cellVal)) {\n        throw new Error(\"Cell is not a Number\");\n      } else {\n        sum += cellVal;\n      }\n    }\n\n    return sum.toString();\n  }\n\n  // Finds all cells that was given in the range and returns the average of all cell values\n  // Evaluates the average of a range or group of cells\n  private averageCells(originCell: string, range: string): string {\n    let sum: number = 0;\n    let cellRange: string[] = [];\n\n    if (range.match(\"^[^:]+:[^:]+$\")) {\n      // regex to match expressions using colon for cell range\n      const [startCell, endCell] = range.split(\":\");\n      cellRange = this.getRangeOfCells(startCell, endCell);\n    } else if (range.match(\"^[A-Za-z]\\\\d+(,\\\\s?[A-Za-z]\\\\d+)*$\")) {\n      // regex to match expressions using comma\n      cellRange = range.split(\",\");\n    } else {\n      throw new Error(`Syntax for reference is not correct. ${range}`);\n    }\n\n    let count = cellRange.length;\n\n    for (let cell of cellRange) {\n      this.addDependency(cell, originCell);\n\n      let cellVal = Number(this.getCellFromReference(cell).getDisplay());\n      if (Number.isNaN(cellVal)) {\n        throw new Error(\"Cell is not a Number\");\n      } else {\n        sum += cellVal;\n      }\n    }\n\n    let average = sum / count;\n    return average.toString();\n  }\n\n  // Returns a list of cells that contains all cells that are represented by a range of cells (A1, C2)\n\n  // Gets all the cells within a range given the start and end of the range\n  private getRangeOfCells(startCell: string, endCell: string): string[] {\n    let cells: string[] = [];\n\n    const startCol = startCell.match(/[A-Z]+/i)![0];\n    const startRow = startCell.match(/\\d+/)![0];\n    const endCol = endCell.match(/[A-Z]+/i)![0];\n    const endRow = endCell.match(/\\d+/)![0];\n\n    let startColIdx = this.getColumnIndex(startCol);\n    let endColIdx = this.getColumnIndex(endCol);\n\n    const startRowIdx = parseInt(startRow);\n    const endRowIdx = parseInt(endRow);\n\n    for (let i = startRowIdx; i <= endRowIdx; i++) {\n      for (let j = startColIdx; j <= endColIdx; j++) {\n        cells.push(this.getColumnName(j) + i);\n      }\n    }\n    return cells;\n  }\n\n  // returns the column name (uppercase alphabetical) given the column index\n  // Gets the character code for a column given the index\n  private getColumnName(columnNumber: number): string {\n    let columnName = \"\";\n    while (columnNumber >= 0) {\n      columnName = String.fromCharCode((columnNumber % 26) + 65) + columnName;\n      columnNumber = Math.floor(columnNumber / 26) - 1;\n    }\n    return columnName;\n  }\n\n  // returns the column index given the column name (uppercase alphabetical)\n  private getColumnIndex(column: string): number {\n    let colIndex = -1;\n    for (let i = 0; i < column.length; i++) {\n      colIndex +=\n        (column[i].charCodeAt(0) - \"A\".charCodeAt(0) + 1) *\n        Math.pow(26, column.length - i - 1);\n    }\n\n    return colIndex;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}