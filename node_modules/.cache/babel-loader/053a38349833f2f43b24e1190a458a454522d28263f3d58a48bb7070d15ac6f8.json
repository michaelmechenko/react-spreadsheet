{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nvar name = 'zeta';\nvar dependencies = ['typed', 'config', 'multiply', 'pow', 'divide', 'factorial', 'equal', 'smallerEq', 'isNegative', 'gamma', 'sin', 'subtract', 'add', '?Complex', '?BigNumber', 'pi'];\nexport var createZeta = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n    config = _ref.config,\n    multiply = _ref.multiply,\n    pow = _ref.pow,\n    divide = _ref.divide,\n    factorial = _ref.factorial,\n    equal = _ref.equal,\n    smallerEq = _ref.smallerEq,\n    isNegative = _ref.isNegative,\n    gamma = _ref.gamma,\n    sin = _ref.sin,\n    subtract = _ref.subtract,\n    add = _ref.add,\n    Complex = _ref.Complex,\n    _BigNumber = _ref.BigNumber,\n    pi = _ref.pi;\n  /**\n   * Compute the Riemann Zeta function of a value using an infinite series for\n   * all of the complex plane using Riemann's Functional equation.\n   *\n   * Based off the paper by Xavier Gourdon and Pascal Sebah\n   * ( http://numbers.computation.free.fr/Constants/Miscellaneous/zetaevaluations.pdf )\n   *\n   * Implementation and slight modification by Anik Patel\n   *\n   * Note: the implementation is accurate up to about 6 digits.\n   *\n   * Syntax:\n   *\n   *    math.zeta(n)\n   *\n   * Examples:\n   *\n   *    math.zeta(5)       // returns 1.0369277551433895\n   *    math.zeta(-0.5)    // returns -0.2078862249773449\n   *    math.zeta(math.i)  // returns 0.0033002236853253153 - 0.4181554491413212i\n   *\n   * See also:\n   *    erf\n   *\n   * @param {number | Complex | BigNumber} s   A Real, Complex or BigNumber parameter to the Riemann Zeta Function\n   * @return {number | Complex | BigNumber}    The Riemann Zeta of `s`\n   */\n  return typed(name, {\n    number: function number(s) {\n      return zetaNumeric(s, function (value) {\n        return value;\n      }, function () {\n        return 20;\n      });\n    },\n    BigNumber: function BigNumber(s) {\n      return zetaNumeric(s, function (value) {\n        return new _BigNumber(value);\n      }, function () {\n        // epsilon is for example 1e-12. Extract the positive exponent 12 from that\n        return Math.abs(Math.log10(config.epsilon));\n      });\n    },\n    Complex: zetaComplex\n  });\n\n  /**\n   * @param {number | BigNumber} s\n   * @param {(value: number) => number | BigNumber} createValue\n   * @param {(value: number | BigNumber | Complex) => number} determineDigits\n   * @returns {number | BigNumber}\n   */\n  function zetaNumeric(s, createValue, determineDigits) {\n    if (equal(s, 0)) {\n      return createValue(-0.5);\n    }\n    if (equal(s, 1)) {\n      return createValue(NaN);\n    }\n    if (!isFinite(s)) {\n      return isNegative(s) ? createValue(NaN) : createValue(1);\n    }\n    return zeta(s, createValue, determineDigits, function (s) {\n      return s;\n    });\n  }\n\n  /**\n   * @param {Complex} s\n   * @returns {Complex}\n   */\n  function zetaComplex(s) {\n    if (s.re === 0 && s.im === 0) {\n      return new Complex(-0.5);\n    }\n    if (s.re === 1) {\n      return new Complex(NaN, NaN);\n    }\n    if (s.re === Infinity && s.im === 0) {\n      return new Complex(1);\n    }\n    if (s.im === Infinity || s.re === -Infinity) {\n      return new Complex(NaN, NaN);\n    }\n    return zeta(s, function (value) {\n      return value;\n    }, function (s) {\n      return Math.round(1.3 * 15 + 0.9 * Math.abs(s.im));\n    }, function (s) {\n      return s.re;\n    });\n  }\n\n  /**\n   * @param {number | BigNumber | Complex} s\n   * @param {(value: number) => number | BigNumber | Complex} createValue\n   * @param {(value: number | BigNumber | Complex) => number} determineDigits\n   * @param {(value: number | BigNumber | Complex) => number} getRe\n   * @returns {*|number}\n   */\n  function zeta(s, createValue, determineDigits, getRe) {\n    var n = determineDigits(s);\n    if (getRe(s) > -(n - 1) / 2) {\n      return f(s, createValue(n), createValue);\n    } else {\n      // Function Equation for reflection to x < 1\n      var c = multiply(pow(2, s), pow(createValue(pi), subtract(s, 1)));\n      c = multiply(c, sin(multiply(divide(createValue(pi), 2), s)));\n      c = multiply(c, gamma(subtract(1, s)));\n      return multiply(c, zeta(subtract(1, s), createValue, determineDigits, getRe));\n    }\n  }\n\n  /**\n   * Calculate a portion of the sum\n   * @param {number | BigNumber} k   a positive integer\n   * @param {number | BigNumber} n   a positive integer\n   * @return {number}    the portion of the sum\n   **/\n  function d(k, n) {\n    var S = k;\n    for (var j = k; smallerEq(j, n); j = add(j, 1)) {\n      var factor = divide(multiply(factorial(add(n, subtract(j, 1))), pow(4, j)), multiply(factorial(subtract(n, j)), factorial(multiply(2, j))));\n      S = add(S, factor);\n    }\n    return multiply(n, S);\n  }\n\n  /**\n   * Calculate the positive Riemann Zeta function\n   * @param {number} s   a real or complex number with s.re > 1\n   * @param {number} n   a positive integer\n   * @param {(number) => number | BigNumber | Complex} createValue\n   * @return {number}    Riemann Zeta of s\n   **/\n  function f(s, n, createValue) {\n    var c = divide(1, multiply(d(createValue(0), n), subtract(1, pow(2, subtract(1, s)))));\n    var S = createValue(0);\n    for (var k = createValue(1); smallerEq(k, n); k = add(k, 1)) {\n      S = add(S, divide(multiply(Math.pow(-1, k - 1), d(k, n)), pow(k, s)));\n    }\n    return multiply(c, S);\n  }\n});","map":{"version":3,"names":["factory","name","dependencies","createZeta","_ref","typed","config","multiply","pow","divide","factorial","equal","smallerEq","isNegative","gamma","sin","subtract","add","Complex","_BigNumber","BigNumber","pi","number","s","zetaNumeric","value","Math","abs","log10","epsilon","zetaComplex","createValue","determineDigits","NaN","isFinite","zeta","re","im","Infinity","round","getRe","n","f","c","d","k","S","j","factor"],"sources":["C:/Users/micha/Documents/mechenko_main/PEDAGOGY/fa23/CS4530/project/team111-project/implementation/node_modules/mathjs/lib/esm/function/special/zeta.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nvar name = 'zeta';\nvar dependencies = ['typed', 'config', 'multiply', 'pow', 'divide', 'factorial', 'equal', 'smallerEq', 'isNegative', 'gamma', 'sin', 'subtract', 'add', '?Complex', '?BigNumber', 'pi'];\nexport var createZeta = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    multiply,\n    pow,\n    divide,\n    factorial,\n    equal,\n    smallerEq,\n    isNegative,\n    gamma,\n    sin,\n    subtract,\n    add,\n    Complex,\n    BigNumber: _BigNumber,\n    pi\n  } = _ref;\n  /**\n   * Compute the Riemann Zeta function of a value using an infinite series for\n   * all of the complex plane using Riemann's Functional equation.\n   *\n   * Based off the paper by Xavier Gourdon and Pascal Sebah\n   * ( http://numbers.computation.free.fr/Constants/Miscellaneous/zetaevaluations.pdf )\n   *\n   * Implementation and slight modification by Anik Patel\n   *\n   * Note: the implementation is accurate up to about 6 digits.\n   *\n   * Syntax:\n   *\n   *    math.zeta(n)\n   *\n   * Examples:\n   *\n   *    math.zeta(5)       // returns 1.0369277551433895\n   *    math.zeta(-0.5)    // returns -0.2078862249773449\n   *    math.zeta(math.i)  // returns 0.0033002236853253153 - 0.4181554491413212i\n   *\n   * See also:\n   *    erf\n   *\n   * @param {number | Complex | BigNumber} s   A Real, Complex or BigNumber parameter to the Riemann Zeta Function\n   * @return {number | Complex | BigNumber}    The Riemann Zeta of `s`\n   */\n  return typed(name, {\n    number: s => zetaNumeric(s, value => value, () => 20),\n    BigNumber: s => zetaNumeric(s, value => new _BigNumber(value), () => {\n      // epsilon is for example 1e-12. Extract the positive exponent 12 from that\n      return Math.abs(Math.log10(config.epsilon));\n    }),\n    Complex: zetaComplex\n  });\n\n  /**\n   * @param {number | BigNumber} s\n   * @param {(value: number) => number | BigNumber} createValue\n   * @param {(value: number | BigNumber | Complex) => number} determineDigits\n   * @returns {number | BigNumber}\n   */\n  function zetaNumeric(s, createValue, determineDigits) {\n    if (equal(s, 0)) {\n      return createValue(-0.5);\n    }\n    if (equal(s, 1)) {\n      return createValue(NaN);\n    }\n    if (!isFinite(s)) {\n      return isNegative(s) ? createValue(NaN) : createValue(1);\n    }\n    return zeta(s, createValue, determineDigits, s => s);\n  }\n\n  /**\n   * @param {Complex} s\n   * @returns {Complex}\n   */\n  function zetaComplex(s) {\n    if (s.re === 0 && s.im === 0) {\n      return new Complex(-0.5);\n    }\n    if (s.re === 1) {\n      return new Complex(NaN, NaN);\n    }\n    if (s.re === Infinity && s.im === 0) {\n      return new Complex(1);\n    }\n    if (s.im === Infinity || s.re === -Infinity) {\n      return new Complex(NaN, NaN);\n    }\n    return zeta(s, value => value, s => Math.round(1.3 * 15 + 0.9 * Math.abs(s.im)), s => s.re);\n  }\n\n  /**\n   * @param {number | BigNumber | Complex} s\n   * @param {(value: number) => number | BigNumber | Complex} createValue\n   * @param {(value: number | BigNumber | Complex) => number} determineDigits\n   * @param {(value: number | BigNumber | Complex) => number} getRe\n   * @returns {*|number}\n   */\n  function zeta(s, createValue, determineDigits, getRe) {\n    var n = determineDigits(s);\n    if (getRe(s) > -(n - 1) / 2) {\n      return f(s, createValue(n), createValue);\n    } else {\n      // Function Equation for reflection to x < 1\n      var c = multiply(pow(2, s), pow(createValue(pi), subtract(s, 1)));\n      c = multiply(c, sin(multiply(divide(createValue(pi), 2), s)));\n      c = multiply(c, gamma(subtract(1, s)));\n      return multiply(c, zeta(subtract(1, s), createValue, determineDigits, getRe));\n    }\n  }\n\n  /**\n   * Calculate a portion of the sum\n   * @param {number | BigNumber} k   a positive integer\n   * @param {number | BigNumber} n   a positive integer\n   * @return {number}    the portion of the sum\n   **/\n  function d(k, n) {\n    var S = k;\n    for (var j = k; smallerEq(j, n); j = add(j, 1)) {\n      var factor = divide(multiply(factorial(add(n, subtract(j, 1))), pow(4, j)), multiply(factorial(subtract(n, j)), factorial(multiply(2, j))));\n      S = add(S, factor);\n    }\n    return multiply(n, S);\n  }\n\n  /**\n   * Calculate the positive Riemann Zeta function\n   * @param {number} s   a real or complex number with s.re > 1\n   * @param {number} n   a positive integer\n   * @param {(number) => number | BigNumber | Complex} createValue\n   * @return {number}    Riemann Zeta of s\n   **/\n  function f(s, n, createValue) {\n    var c = divide(1, multiply(d(createValue(0), n), subtract(1, pow(2, subtract(1, s)))));\n    var S = createValue(0);\n    for (var k = createValue(1); smallerEq(k, n); k = add(k, 1)) {\n      S = add(S, divide(multiply((-1) ** (k - 1), d(k, n)), pow(k, s)));\n    }\n    return multiply(c, S);\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}