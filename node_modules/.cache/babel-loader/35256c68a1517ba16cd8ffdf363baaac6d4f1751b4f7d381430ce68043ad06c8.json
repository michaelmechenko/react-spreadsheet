{"ast":null,"code":"import { Expressions } from \"../../expressions/expression-enums.model\";\nimport { SpreadsheetCellModel } from \"./cells/spreadsheet-cell.model\";\n\n/**\n * Represents the Spreadsheet Page of the spreadsheet application.\n * Every page is first initialized as a 15x15 matrix\n */\nexport class SpreadSheetPageModel {\n  // Instantiates spreadsheet page that defaults to a 12x12 page\n  constructor(name = \"\", rows = 12, cols = 12, data) {\n    this._sheetName = void 0;\n    this.sheet = void 0;\n    this._sheetName = name;\n    this.sheet = [];\n    for (let row = 0; row < rows; row++) {\n      this.sheet[row] = [];\n      for (let col = 0; col < cols; col++) {\n        if (data === undefined) {\n          this.sheet[row][col] = new SpreadsheetCellModel();\n        } else {\n          let cell = new SpreadsheetCellModel();\n          cell.setBuffer(data[row][col]);\n          this.sheet[row][col] = cell;\n        }\n      }\n    }\n  }\n\n  // Returns number of rows in spreadsheet page\n  getNumRows() {\n    return this.sheet.length;\n  }\n\n  // Returns number of columns in spreadsheet page\n  getNumCols() {\n    return this.sheet[0].length;\n  }\n\n  // Returns the name of this spreadsheet page\n  getSheetName() {\n    return this._sheetName;\n  }\n\n  // Sets the name of this spreadsheet to be the given name\n  setSheetName(newName) {\n    this._sheetName = newName;\n  }\n\n  // Gets the display value of a cell given the reference string\n  getValueAtCell(cellReference) {\n    const cell = this.getCellFromReference(cellReference);\n    return cell.getDisplay();\n  }\n\n  // Returns the buffer value of this cell\n  getCellBuffer(cellReference) {\n    const cell = this.getCellFromReference(cellReference);\n    return cell.getBuffer();\n  }\n\n  /**\n   * sets the buffer of the given cell reference to the value\n   * does a check to see if the value is an expression which is indicated by '='\n   * Adds a dependency between the given cells\n   * Throws an error if a cycle would be created by the new dependency and does not add the dependency\n   * @param fromCell : cell to add a dependency\n   * @param toCell : dependency cell\n   */\n  addDependency(fromCell, toCell) {\n    if (this.validDependency(fromCell, toCell)) {\n      this.getCellFromReference(fromCell).addDependency(toCell);\n    } else {\n      throw new Error(\"Cycle Error\");\n    }\n  }\n\n  // Checks if a dependency between the given cells is valid\n  // A dependency is valid is no cycle is created by the dependency\n  validDependency(fromCell, toCell) {\n    if (this.getCellFromReference(toCell).getDependencies().includes(fromCell)) {\n      return false;\n    }\n    this.getCellFromReference(fromCell).getDependencies().forEach(dependency => {\n      return this.validDependency(dependency, toCell);\n    });\n    return true;\n  }\n\n  /**\n   * Sets the user's input (buffer) to the desired cell.\n   * This undergoes a lot of logic and regex checks to correctly evaluate the\n   * buffer that is given.\n   * This method is the only way for the desired cell's display value to be changed.\n   * @param cellReference : string reference of a cell (A1)\n   * @param buffer : string to be read and parsed\n   */\n  setValue(cellReference, buffer) {\n    const cell = this.getCellFromReference(cellReference);\n    let expression = \"\";\n    // logic if buffer is an expression (starts with '=')\n    if (buffer.startsWith(\"=\", 0)) {\n      try {\n        expression = this.evaluateExpression(cellReference, buffer.substring(1));\n        cell.setBuffer(buffer, expression);\n      } catch (error) {\n        throw new Error(`Invalid Expression ${error}`);\n      }\n    } else {\n      cell.setBuffer(buffer);\n    }\n    this.updateReferences(cell);\n  }\n\n  // Updates the cells that reference the given cell\n  updateReferences(cell) {\n    if (cell.getDependencies().length === 0) {\n      return;\n    } else {\n      cell.getDependencies().forEach(c => {\n        this.setValue(c, this.getCellBuffer(c));\n        const d = this.getCellFromReference(c);\n        this.updateReferences(d);\n      });\n    }\n  }\n\n  // Parses a string reference to get the correct cell from spreadsheet page\n  // Returns the cell object given the cell reference\n  getCellFromReference(cellReference) {\n    const colArr = cellReference.match(/[A-Z]+/i);\n    const rowArr = cellReference.match(/\\d+/);\n    if (colArr == null || rowArr == null) {\n      throw new Error(\"Invalid row or col reference given\");\n    }\n    const colChars = colArr[0];\n    const rowChars = rowArr[0];\n    let col = this.getColumnIndex(colChars);\n    const row = parseInt(rowChars) - 1;\n    if (col > this.getNumCols() || row > this.getNumRows()) {\n      throw new Error(\"Reference out of bounds!\");\n    }\n    return this.sheet[row][col];\n  }\n\n  // Returns the cell at a given row and column\n  // Should be able to use getters and setters on the returned cell??\n  getCellAtRowCol(row, col) {\n    return this.sheet[row][col];\n  }\n\n  // Adds a row to the spreadsheet page below the given row index\n  addRow(index) {\n    if (index < 0) {\n      throw new Error(\"Invalid row index\");\n    }\n    if (index > this.sheet[0].length) {\n      index = this.sheet[0].length;\n    }\n    const newRow = [];\n    for (let col = 0; col < this.sheet[0].length; col++) {\n      newRow[col] = new SpreadsheetCellModel();\n    }\n    this.sheet.splice(index, 0, newRow);\n    this.shiftDependenciesDown(index);\n  }\n\n  // shifts all dependencies within the spreadsheet down that are affected\n  // by adding a row at the given index\n  // Also updates the buffers of every cell that refers to a changed cell to the correct reference\n  shiftDependenciesDown(index) {\n    for (let row = 0; row < this.getNumRows(); row++) {\n      for (let col = 0; col < this.getNumCols(); col++) {\n        const currentBuffer = this.sheet[row][col].getBuffer();\n        let newBuffer = this.shiftBuffer(currentBuffer, \"down\", index);\n        this.setValue(`${this.getColumnName(col)}${row + 1}`, newBuffer);\n        this.sheet[row][col].shiftCellDependencies(1, 0, index, -1);\n      }\n    }\n  }\n\n  // shifts all dependencies within the spreadsheet up that are\n  // affected by removing a row at the given index\n  // Also updates the buffers of every cell that refers to a changed cell to the correct reference\n  shiftDependenciesUp(index) {\n    for (let row = 0; row < this.getNumRows(); row++) {\n      for (let col = 0; col < this.getNumCols(); col++) {\n        const currentBuffer = this.sheet[row][col].getBuffer();\n        let newBuffer = this.shiftBuffer(currentBuffer, \"up\", index);\n        this.setValue(`${this.getColumnName(col)}${row + 1}`, newBuffer);\n        this.sheet[row][col].shiftCellDependencies(-1, 0, index, -1);\n      }\n    }\n  }\n\n  // shifts right all dependencies within the spreadsheet page that are affected\n  // by adding a column at the given index\n  // Also updates the buffers of every cell that refers to a changed cell to the correct reference\n  shiftDependenciesRight(index) {\n    for (let row = 0; row < this.getNumRows(); row++) {\n      for (let col = 0; col < this.getNumCols(); col++) {\n        const currentBuffer = this.sheet[row][col].getBuffer();\n        let newBuffer = this.shiftBuffer(currentBuffer, \"right\", index);\n        this.setValue(`${this.getColumnName(col)}${row + 1}`, newBuffer);\n        this.sheet[row][col].shiftCellDependencies(0, 1, -1, index);\n      }\n    }\n  }\n\n  // shifts left all dependencies within the spreadsheet page that are\n  // affected by removing a column at the given index\n  // Also updates the buffers of every cell that refers to a changed cell to the correct reference\n  shiftDependenciesLeft(index) {\n    for (let row = 0; row < this.getNumRows(); row++) {\n      for (let col = 0; col < this.getNumCols(); col++) {\n        const currentBuffer = this.sheet[row][col].getBuffer();\n        let newBuffer = this.shiftBuffer(currentBuffer, \"left\", index);\n        this.setValue(`${this.getColumnName(col)}${row + 1}`, newBuffer);\n        this.sheet[row][col].shiftCellDependencies(0, -1, -1, index);\n      }\n    }\n  }\n\n  // Adds a column to the spreadsheet page to the right of the given column index\n  addColumn(index) {\n    if (index < 0) {\n      throw new Error(\"Invalid column index\");\n    }\n    if (index > this.sheet[0].length) {\n      index = this.sheet[0].length;\n    }\n    for (let row = 0; row < this.sheet.length; row++) {\n      this.sheet[row].splice(index, 0, new SpreadsheetCellModel());\n    }\n    this.shiftDependenciesRight(index);\n  }\n\n  // Removes the row of the spreadsheet page at the given row index\n  removeRow(index) {\n    if (index < 0 || index >= this.sheet.length) {\n      throw new Error(\"Invalid row index\");\n    }\n    this.sheet.splice(index, 1);\n    this.shiftDependenciesUp(index);\n  }\n\n  // Removes the column of the spreadsheet page at the given column index\n  removeColumn(index) {\n    if (index < 0 || index >= this.sheet[0].length) {\n      throw new Error(\"Invalid column index\");\n    }\n    for (let row = 0; row < this.sheet.length; row++) {\n      this.sheet[row].splice(index, 1);\n    }\n    this.shiftDependenciesLeft(index);\n  }\n\n  // Replaces the range or reference function if found in the expression with the actual number\n  // Evaluates the given reference expression at the given originCell\n  evaluateExpression(originCell, input) {\n    try {\n      while (input.includes(Expressions.REF)) {\n        input = this.evaluateRefExpressions(originCell, input);\n      }\n      while (input.includes(Expressions.SUM)) {\n        input = this.evaluateSumExpressions(originCell, input);\n      }\n      while (input.includes(Expressions.AVG)) {\n        input = this.evaluateAvgExpressions(originCell, input);\n      }\n      return input;\n    } catch (error) {\n      throw new Error(`Failed to replace expressions ${error}`);\n    }\n  }\n\n  // replaces any 'REF(x)' found using regex with the correct cell display\n  // Parses through the reference expression, adding a dependency and reformatting\n  // the expression to be evaluated\n  evaluateRefExpressions(originCell, input) {\n    const refRegex = /REF\\(([^)]+)\\)/g;\n    return input.replace(refRegex, (_, cellReference) => {\n      this.addDependency(cellReference, originCell);\n      return this.getCellFromReference(cellReference).getDisplay();\n    });\n  }\n\n  // replaces any 'SUM(A1:A3)' found using regex with the correct sum\n  // Parses through the sum expression,\n  // reformatting the expression to be evaluated\n  evaluateSumExpressions(originCell, input) {\n    const sumRegex = /SUM\\(([^)]+)\\)/g;\n    return input.replace(sumRegex, (_, range) => this.sumCells(originCell, range));\n  }\n\n  // replaces any 'AVG(A1:A3)' found using regex with the correct average\n  // Parses through the average expression,\n  // reformatting the expression to be evaluated\n  evaluateAvgExpressions(originCell, input) {\n    const avgRegex = /AVG\\(([^)]+)\\)/g;\n    return input.replace(avgRegex, (_, range) => this.averageCells(originCell, range));\n  }\n\n  // Evaluates the sum of a range or group of cells\n  sumCells(originCell, range) {\n    let sum = 0;\n    let cellRange = [];\n\n    // regex to match expressions using colon for cell range\n    if (range.match(\"^[^:]+:[^:]+$\")) {\n      const [startCell, endCell] = range.split(\":\");\n      cellRange = this.getRangeOfCells(startCell, endCell);\n      // regex to match expressions using comma\n    } else if (range.match(\"^[A-Za-z]\\\\d+(,\\\\s?[A-Za-z]\\\\d+)*$\")) {\n      cellRange = range.split(\",\");\n    } else {\n      throw new Error(`Syntax for reference is not correct. ${range}`);\n    }\n    for (let cell of cellRange) {\n      this.addDependency(cell, originCell);\n      let cellVal = Number(this.getCellFromReference(cell).getDisplay());\n      if (Number.isNaN(cellVal)) {\n        throw new Error(\"Cell is not a Number\");\n      } else {\n        sum += cellVal;\n      }\n    }\n    return sum.toString();\n  }\n\n  // Finds all cells that was given in the range and returns the average of all cell values\n  // Evaluates the average of a range or group of cells\n  averageCells(originCell, range) {\n    let sum = 0;\n    let cellRange = [];\n\n    // regex to match expressions using colon for cell range\n    if (range.match(\"^[^:]+:[^:]+$\")) {\n      const [startCell, endCell] = range.split(\":\");\n      cellRange = this.getRangeOfCells(startCell, endCell);\n      // regex to match expressions using comma\n    } else if (range.match(\"^[A-Za-z]\\\\d+(,\\\\s?[A-Za-z]\\\\d+)*$\")) {\n      cellRange = range.split(\",\");\n    } else {\n      throw new Error(`Syntax for reference is not correct. ${range}`);\n    }\n    let count = cellRange.length;\n    for (let cell of cellRange) {\n      this.addDependency(cell, originCell);\n      let cellVal = Number(this.getCellFromReference(cell).getDisplay());\n      if (Number.isNaN(cellVal)) {\n        throw new Error(\"Cell is not a Number\");\n      } else {\n        sum += cellVal;\n      }\n    }\n    let average = sum / count;\n    return average.toString();\n  }\n\n  // Returns a list of cells that contains all cells that are represented by a range of cells (A1, C2)\n\n  // Gets all the cells within a range given the start and end of the range\n  getRangeOfCells(startCell, endCell) {\n    let cells = [];\n    const startCol = startCell.match(/[A-Z]+/i)[0];\n    const startRow = startCell.match(/\\d+/)[0];\n    const endCol = endCell.match(/[A-Z]+/i)[0];\n    const endRow = endCell.match(/\\d+/)[0];\n    let startColIdx = this.getColumnIndex(startCol);\n    let endColIdx = this.getColumnIndex(endCol);\n    const startRowIdx = parseInt(startRow);\n    const endRowIdx = parseInt(endRow);\n    for (let i = startRowIdx; i <= endRowIdx; i++) {\n      for (let j = startColIdx; j <= endColIdx; j++) {\n        cells.push(this.getColumnName(j) + i);\n      }\n    }\n    return cells;\n  }\n\n  // returns the column name (uppercase alphabetical) given the column index\n  // Gets the character code for a column given the index\n  getColumnName(columnNumber) {\n    let columnName = \"\";\n    while (columnNumber >= 0) {\n      columnName = String.fromCharCode(columnNumber % 26 + 65) + columnName;\n      columnNumber = Math.floor(columnNumber / 26) - 1;\n    }\n    return columnName;\n  }\n\n  // returns the column index given the column name (uppercase alphabetical)\n  getColumnIndex(column) {\n    let colIndex = -1;\n    for (let i = 0; i < column.length; i++) {\n      colIndex += (column[i].charCodeAt(0) - \"A\".charCodeAt(0) + 1) * Math.pow(26, column.length - i - 1);\n    }\n    return colIndex;\n  }\n  shiftBuffer(buffer, option, index) {\n    // Regular expression to match cell references like \"AA2\" or \"AA18\"\n    const cellReferenceRegex = /[A-Z]+[0-9]+/g;\n\n    // Check if currentBuffer contains any cell references\n    const matches = buffer.match(cellReferenceRegex);\n    let updatedBuffer = buffer;\n    if (matches) {\n      // Update the buffer for each matching cell reference\n      matches.forEach(cellReference => {\n        const [colChars, rowStr] = cellReference;\n        const cellRow = parseInt(rowStr) || 0;\n        if (option === \"down\") {\n          if (cellRow > index) {\n            // Replace the row value in the cell reference with (cellRow + 1)\n            updatedBuffer = updatedBuffer.replace(cellReference, `${colChars}${cellRow + 1}`);\n          }\n        } else if (option === \"up\") {\n          if (cellRow > index) {\n            // Replace the row value in the cell reference with (cellRow - 1)\n            updatedBuffer = updatedBuffer.replace(cellReference, `${colChars}${cellRow - 1}`);\n          }\n        } else if (option === \"right\") {\n          if (cellRow > index + 1) {\n            // Replace the col value in the cell reference with (col + 1)\n            updatedBuffer = updatedBuffer.replace(cellReference, `${this.getColumnName(this.getColumnIndex(colChars) + 1)}${cellRow}`);\n          }\n        } else if (option === \"left\") {\n          if (cellRow > index + 1) {\n            // Replace the col value in the cell reference with (col - 1)\n            updatedBuffer = updatedBuffer.replace(cellReference, `${this.getColumnName(this.getColumnIndex(colChars) - 1)}${cellRow}`);\n          }\n        }\n      });\n    }\n    return updatedBuffer;\n  }\n\n  // returns a 2D array with only the buffers of every cell in the sheet\n  getData() {\n    const output = [];\n    for (let r = 0; r < this.getNumRows(); r++) {\n      const row = [];\n      for (let c = 0; c < this.getNumCols(); c++) {\n        row.push(this.sheet[r][c].getBuffer());\n      }\n      output.push(row);\n    }\n    return output;\n  }\n}","map":{"version":3,"names":["Expressions","SpreadsheetCellModel","SpreadSheetPageModel","constructor","name","rows","cols","data","_sheetName","sheet","row","col","undefined","cell","setBuffer","getNumRows","length","getNumCols","getSheetName","setSheetName","newName","getValueAtCell","cellReference","getCellFromReference","getDisplay","getCellBuffer","getBuffer","addDependency","fromCell","toCell","validDependency","Error","getDependencies","includes","forEach","dependency","setValue","buffer","expression","startsWith","evaluateExpression","substring","error","updateReferences","c","d","colArr","match","rowArr","colChars","rowChars","getColumnIndex","parseInt","getCellAtRowCol","addRow","index","newRow","splice","shiftDependenciesDown","currentBuffer","newBuffer","shiftBuffer","getColumnName","shiftCellDependencies","shiftDependenciesUp","shiftDependenciesRight","shiftDependenciesLeft","addColumn","removeRow","removeColumn","originCell","input","REF","evaluateRefExpressions","SUM","evaluateSumExpressions","AVG","evaluateAvgExpressions","refRegex","replace","_","sumRegex","range","sumCells","avgRegex","averageCells","sum","cellRange","startCell","endCell","split","getRangeOfCells","cellVal","Number","isNaN","toString","count","average","cells","startCol","startRow","endCol","endRow","startColIdx","endColIdx","startRowIdx","endRowIdx","i","j","push","columnNumber","columnName","String","fromCharCode","Math","floor","column","colIndex","charCodeAt","pow","option","cellReferenceRegex","matches","updatedBuffer","rowStr","cellRow","getData","output","r"],"sources":["C:/Users/micha/Documents/mechenko_main/PEDAGOGY/fa23/CS4530/project/team111-project/implementation/src/model/domain/spreadsheet-page.model.ts"],"sourcesContent":["import { Expressions } from \"../../expressions/expression-enums.model\";\nimport { ICell } from \"../interfaces/cell.interface\";\nimport { ISpreadsheetPage } from \"../interfaces/spreadsheet-page.interface\";\nimport { SpreadsheetCellModel } from \"./cells/spreadsheet-cell.model\";\n\n/**\n * Represents the Spreadsheet Page of the spreadsheet application.\n * Every page is first initialized as a 15x15 matrix\n */\nexport class SpreadSheetPageModel implements ISpreadsheetPage {\n  private _sheetName: string;\n  private sheet: SpreadsheetCellModel[][];\n\n  // Instantiates spreadsheet page that defaults to a 12x12 page\n  public constructor(\n    name: string = \"\",\n    rows: number = 12,\n    cols: number = 12,\n    data?: string[][]\n  ) {\n    this._sheetName = name;\n    this.sheet = [];\n\n    for (let row: number = 0; row < rows; row++) {\n      this.sheet[row] = [];\n      for (let col: number = 0; col < cols; col++) {\n        if (data === undefined) {\n          this.sheet[row][col] = new SpreadsheetCellModel();\n        } else {\n          let cell: SpreadsheetCellModel = new SpreadsheetCellModel();\n          cell.setBuffer(data[row][col]);\n          this.sheet[row][col] = cell;\n        }\n      }\n    }\n  }\n\n  // Returns number of rows in spreadsheet page\n  public getNumRows(): number {\n    return this.sheet.length;\n  }\n\n  // Returns number of columns in spreadsheet page\n  public getNumCols(): number {\n    return this.sheet[0].length;\n  }\n\n  // Returns the name of this spreadsheet page\n  public getSheetName(): string {\n    return this._sheetName;\n  }\n\n  // Sets the name of this spreadsheet to be the given name\n  public setSheetName(newName: string) {\n    this._sheetName = newName;\n  }\n\n  // Gets the display value of a cell given the reference string\n  public getValueAtCell(cellReference: string): string {\n    const cell = this.getCellFromReference(cellReference);\n    return cell.getDisplay();\n  }\n\n  // Returns the buffer value of this cell\n  public getCellBuffer(cellReference: string): string {\n    const cell = this.getCellFromReference(cellReference);\n    return cell.getBuffer();\n  }\n\n  /**\n   * sets the buffer of the given cell reference to the value\n   * does a check to see if the value is an expression which is indicated by '='\n   * Adds a dependency between the given cells\n   * Throws an error if a cycle would be created by the new dependency and does not add the dependency\n   * @param fromCell : cell to add a dependency\n   * @param toCell : dependency cell\n   */\n  private addDependency(fromCell: string, toCell: string): void {\n    if (this.validDependency(fromCell, toCell)) {\n      this.getCellFromReference(fromCell).addDependency(toCell);\n    } else {\n      throw new Error(\"Cycle Error\");\n    }\n  }\n\n  // Checks if a dependency between the given cells is valid\n  // A dependency is valid is no cycle is created by the dependency\n  private validDependency(fromCell: string, toCell: string) {\n    if (\n      this.getCellFromReference(toCell).getDependencies().includes(fromCell)\n    ) {\n      return false;\n    }\n    this.getCellFromReference(fromCell)\n      .getDependencies()\n      .forEach((dependency) => {\n        return this.validDependency(dependency, toCell);\n      });\n\n    return true;\n  }\n\n  /**\n   * Sets the user's input (buffer) to the desired cell.\n   * This undergoes a lot of logic and regex checks to correctly evaluate the\n   * buffer that is given.\n   * This method is the only way for the desired cell's display value to be changed.\n   * @param cellReference : string reference of a cell (A1)\n   * @param buffer : string to be read and parsed\n   */\n  public setValue(cellReference: string, buffer: string): void {\n    const cell = this.getCellFromReference(cellReference);\n    let expression = \"\";\n    // logic if buffer is an expression (starts with '=')\n    if (buffer.startsWith(\"=\", 0)) {\n      try {\n        expression = this.evaluateExpression(\n          cellReference,\n          buffer.substring(1)\n        );\n        cell.setBuffer(buffer, expression);\n      } catch (error) {\n        throw new Error(`Invalid Expression ${error}`);\n      }\n    } else {\n      cell.setBuffer(buffer);\n    }\n\n    this.updateReferences(cell);\n  }\n\n  // Updates the cells that reference the given cell\n  private updateReferences(cell: ICell): void {\n    if (cell.getDependencies().length === 0) {\n      return;\n    } else {\n      cell.getDependencies().forEach((c) => {\n        this.setValue(c, this.getCellBuffer(c));\n        const d = this.getCellFromReference(c);\n        this.updateReferences(d);\n      });\n    }\n  }\n\n  // Parses a string reference to get the correct cell from spreadsheet page\n  // Returns the cell object given the cell reference\n  public getCellFromReference(cellReference: string): SpreadsheetCellModel {\n    const colArr = cellReference.match(/[A-Z]+/i);\n    const rowArr = cellReference.match(/\\d+/);\n\n    if (colArr == null || rowArr == null) {\n      throw new Error(\"Invalid row or col reference given\");\n    }\n    const colChars = colArr[0];\n    const rowChars = rowArr[0];\n    let col = this.getColumnIndex(colChars);\n\n    const row = parseInt(rowChars) - 1;\n\n    if (col > this.getNumCols() || row > this.getNumRows()) {\n      throw new Error(\"Reference out of bounds!\");\n    }\n\n    return this.sheet[row][col];\n  }\n\n  // Returns the cell at a given row and column\n  // Should be able to use getters and setters on the returned cell??\n  public getCellAtRowCol(row: number, col: number): SpreadsheetCellModel {\n    return this.sheet[row][col];\n  }\n\n  // Adds a row to the spreadsheet page below the given row index\n  public addRow(index: number): void {\n    if (index < 0) {\n      throw new Error(\"Invalid row index\");\n    }\n    if (index > this.sheet[0].length) {\n      index = this.sheet[0].length;\n    }\n\n    const newRow: SpreadsheetCellModel[] = [];\n    for (let col = 0; col < this.sheet[0].length; col++) {\n      newRow[col] = new SpreadsheetCellModel();\n    }\n\n    this.sheet.splice(index, 0, newRow);\n\n    this.shiftDependenciesDown(index);\n  }\n\n  // shifts all dependencies within the spreadsheet down that are affected\n  // by adding a row at the given index\n  // Also updates the buffers of every cell that refers to a changed cell to the correct reference\n  private shiftDependenciesDown(index: number) {\n    for (let row = 0; row < this.getNumRows(); row++) {\n      for (let col = 0; col < this.getNumCols(); col++) {\n        const currentBuffer = this.sheet[row][col].getBuffer();\n\n        let newBuffer: string = this.shiftBuffer(currentBuffer, \"down\", index);\n        this.setValue(`${this.getColumnName(col)}${row + 1}`, newBuffer);\n\n        this.sheet[row][col].shiftCellDependencies(1, 0, index, -1);\n      }\n    }\n  }\n\n  // shifts all dependencies within the spreadsheet up that are\n  // affected by removing a row at the given index\n  // Also updates the buffers of every cell that refers to a changed cell to the correct reference\n  private shiftDependenciesUp(index: number) {\n    for (let row = 0; row < this.getNumRows(); row++) {\n      for (let col = 0; col < this.getNumCols(); col++) {\n        const currentBuffer = this.sheet[row][col].getBuffer();\n\n        let newBuffer: string = this.shiftBuffer(currentBuffer, \"up\", index);\n        this.setValue(`${this.getColumnName(col)}${row + 1}`, newBuffer);\n\n        this.sheet[row][col].shiftCellDependencies(-1, 0, index, -1);\n      }\n    }\n  }\n\n  // shifts right all dependencies within the spreadsheet page that are affected\n  // by adding a column at the given index\n  // Also updates the buffers of every cell that refers to a changed cell to the correct reference\n  private shiftDependenciesRight(index: number) {\n    for (let row = 0; row < this.getNumRows(); row++) {\n      for (let col = 0; col < this.getNumCols(); col++) {\n        const currentBuffer = this.sheet[row][col].getBuffer();\n\n        let newBuffer: string = this.shiftBuffer(currentBuffer, \"right\", index);\n        this.setValue(`${this.getColumnName(col)}${row + 1}`, newBuffer);\n\n        this.sheet[row][col].shiftCellDependencies(0, 1, -1, index);\n      }\n    }\n  }\n\n  // shifts left all dependencies within the spreadsheet page that are\n  // affected by removing a column at the given index\n  // Also updates the buffers of every cell that refers to a changed cell to the correct reference\n  private shiftDependenciesLeft(index: number) {\n    for (let row = 0; row < this.getNumRows(); row++) {\n      for (let col = 0; col < this.getNumCols(); col++) {\n        const currentBuffer = this.sheet[row][col].getBuffer();\n\n        let newBuffer: string = this.shiftBuffer(currentBuffer, \"left\", index);\n        this.setValue(`${this.getColumnName(col)}${row + 1}`, newBuffer);\n\n        this.sheet[row][col].shiftCellDependencies(0, -1, -1, index);\n      }\n    }\n  }\n\n  // Adds a column to the spreadsheet page to the right of the given column index\n  public addColumn(index: number): void {\n    if (index < 0) {\n      throw new Error(\"Invalid column index\");\n    }\n    if (index > this.sheet[0].length) {\n      index = this.sheet[0].length;\n    }\n\n    for (let row = 0; row < this.sheet.length; row++) {\n      this.sheet[row].splice(index, 0, new SpreadsheetCellModel());\n    }\n\n    this.shiftDependenciesRight(index);\n  }\n\n  // Removes the row of the spreadsheet page at the given row index\n  public removeRow(index: number): void {\n    if (index < 0 || index >= this.sheet.length) {\n      throw new Error(\"Invalid row index\");\n    }\n\n    this.sheet.splice(index, 1);\n\n    this.shiftDependenciesUp(index);\n  }\n\n  // Removes the column of the spreadsheet page at the given column index\n  public removeColumn(index: number): void {\n    if (index < 0 || index >= this.sheet[0].length) {\n      throw new Error(\"Invalid column index\");\n    }\n\n    for (let row = 0; row < this.sheet.length; row++) {\n      this.sheet[row].splice(index, 1);\n    }\n\n    this.shiftDependenciesLeft(index);\n  }\n\n  // Replaces the range or reference function if found in the expression with the actual number\n  // Evaluates the given reference expression at the given originCell\n  private evaluateExpression(originCell: string, input: string): string {\n    try {\n      while (input.includes(Expressions.REF)) {\n        input = this.evaluateRefExpressions(originCell, input);\n      }\n\n      while (input.includes(Expressions.SUM)) {\n        input = this.evaluateSumExpressions(originCell, input);\n      }\n\n      while (input.includes(Expressions.AVG)) {\n        input = this.evaluateAvgExpressions(originCell, input);\n      }\n\n      return input;\n    } catch (error) {\n      throw new Error(`Failed to replace expressions ${error}`);\n    }\n  }\n\n  // replaces any 'REF(x)' found using regex with the correct cell display\n  // Parses through the reference expression, adding a dependency and reformatting\n  // the expression to be evaluated\n  private evaluateRefExpressions(originCell: string, input: string): string {\n    const refRegex = /REF\\(([^)]+)\\)/g;\n    return input.replace(refRegex, (_, cellReference) => {\n      this.addDependency(cellReference, originCell);\n      return this.getCellFromReference(cellReference).getDisplay();\n    });\n  }\n\n  // replaces any 'SUM(A1:A3)' found using regex with the correct sum\n  // Parses through the sum expression,\n  // reformatting the expression to be evaluated\n  private evaluateSumExpressions(originCell: string, input: string): string {\n    const sumRegex = /SUM\\(([^)]+)\\)/g;\n    return input.replace(sumRegex, (_, range) =>\n      this.sumCells(originCell, range)\n    );\n  }\n\n  // replaces any 'AVG(A1:A3)' found using regex with the correct average\n  // Parses through the average expression,\n  // reformatting the expression to be evaluated\n  private evaluateAvgExpressions(originCell: string, input: string): string {\n    const avgRegex = /AVG\\(([^)]+)\\)/g;\n    return input.replace(avgRegex, (_, range) =>\n      this.averageCells(originCell, range)\n    );\n  }\n\n  // Evaluates the sum of a range or group of cells\n  private sumCells(originCell: string, range: string): string {\n    let sum: number = 0;\n    let cellRange: string[] = [];\n\n    // regex to match expressions using colon for cell range\n    if (range.match(\"^[^:]+:[^:]+$\")) {\n      const [startCell, endCell] = range.split(\":\");\n      cellRange = this.getRangeOfCells(startCell, endCell);\n      // regex to match expressions using comma\n    } else if (range.match(\"^[A-Za-z]\\\\d+(,\\\\s?[A-Za-z]\\\\d+)*$\")) {\n      cellRange = range.split(\",\");\n    } else {\n      throw new Error(`Syntax for reference is not correct. ${range}`);\n    }\n\n    for (let cell of cellRange) {\n      this.addDependency(cell, originCell);\n\n      let cellVal = Number(this.getCellFromReference(cell).getDisplay());\n      if (Number.isNaN(cellVal)) {\n        throw new Error(\"Cell is not a Number\");\n      } else {\n        sum += cellVal;\n      }\n    }\n\n    return sum.toString();\n  }\n\n  // Finds all cells that was given in the range and returns the average of all cell values\n  // Evaluates the average of a range or group of cells\n  private averageCells(originCell: string, range: string): string {\n    let sum: number = 0;\n    let cellRange: string[] = [];\n\n    // regex to match expressions using colon for cell range\n    if (range.match(\"^[^:]+:[^:]+$\")) {\n      const [startCell, endCell] = range.split(\":\");\n      cellRange = this.getRangeOfCells(startCell, endCell);\n      // regex to match expressions using comma\n    } else if (range.match(\"^[A-Za-z]\\\\d+(,\\\\s?[A-Za-z]\\\\d+)*$\")) {\n      cellRange = range.split(\",\");\n    } else {\n      throw new Error(`Syntax for reference is not correct. ${range}`);\n    }\n\n    let count = cellRange.length;\n\n    for (let cell of cellRange) {\n      this.addDependency(cell, originCell);\n\n      let cellVal = Number(this.getCellFromReference(cell).getDisplay());\n      if (Number.isNaN(cellVal)) {\n        throw new Error(\"Cell is not a Number\");\n      } else {\n        sum += cellVal;\n      }\n    }\n\n    let average = sum / count;\n    return average.toString();\n  }\n\n  // Returns a list of cells that contains all cells that are represented by a range of cells (A1, C2)\n\n  // Gets all the cells within a range given the start and end of the range\n  private getRangeOfCells(startCell: string, endCell: string): string[] {\n    let cells: string[] = [];\n\n    const startCol = startCell.match(/[A-Z]+/i)![0];\n    const startRow = startCell.match(/\\d+/)![0];\n    const endCol = endCell.match(/[A-Z]+/i)![0];\n    const endRow = endCell.match(/\\d+/)![0];\n\n    let startColIdx = this.getColumnIndex(startCol);\n    let endColIdx = this.getColumnIndex(endCol);\n\n    const startRowIdx = parseInt(startRow);\n    const endRowIdx = parseInt(endRow);\n\n    for (let i = startRowIdx; i <= endRowIdx; i++) {\n      for (let j = startColIdx; j <= endColIdx; j++) {\n        cells.push(this.getColumnName(j) + i);\n      }\n    }\n    return cells;\n  }\n\n  // returns the column name (uppercase alphabetical) given the column index\n  // Gets the character code for a column given the index\n  private getColumnName(columnNumber: number): string {\n    let columnName = \"\";\n    while (columnNumber >= 0) {\n      columnName = String.fromCharCode((columnNumber % 26) + 65) + columnName;\n      columnNumber = Math.floor(columnNumber / 26) - 1;\n    }\n    return columnName;\n  }\n\n  // returns the column index given the column name (uppercase alphabetical)\n  private getColumnIndex(column: string): number {\n    let colIndex = -1;\n    for (let i = 0; i < column.length; i++) {\n      colIndex +=\n        (column[i].charCodeAt(0) - \"A\".charCodeAt(0) + 1) *\n        Math.pow(26, column.length - i - 1);\n    }\n    return colIndex;\n  }\n\n  private shiftBuffer(buffer: string, option: string, index: number): string {\n    // Regular expression to match cell references like \"AA2\" or \"AA18\"\n    const cellReferenceRegex = /[A-Z]+[0-9]+/g;\n\n    // Check if currentBuffer contains any cell references\n    const matches = buffer.match(cellReferenceRegex);\n\n    let updatedBuffer = buffer;\n\n    if (matches) {\n      // Update the buffer for each matching cell reference\n      matches.forEach((cellReference) => {\n        const [colChars, rowStr] = cellReference;\n        const cellRow = parseInt(rowStr) || 0;\n\n        if (option === \"down\") {\n          if (cellRow > index) {\n            // Replace the row value in the cell reference with (cellRow + 1)\n            updatedBuffer = updatedBuffer.replace(\n              cellReference,\n              `${colChars}${cellRow + 1}`\n            );\n          }\n        } else if (option === \"up\") {\n          if (cellRow > index) {\n            // Replace the row value in the cell reference with (cellRow - 1)\n            updatedBuffer = updatedBuffer.replace(\n              cellReference,\n              `${colChars}${cellRow - 1}`\n            );\n          }\n        } else if (option === \"right\") {\n          if (cellRow > index + 1) {\n            // Replace the col value in the cell reference with (col + 1)\n            updatedBuffer = updatedBuffer.replace(\n              cellReference,\n              `${this.getColumnName(\n                this.getColumnIndex(colChars) + 1\n              )}${cellRow}`\n            );\n          }\n        } else if (option === \"left\") {\n          if (cellRow > index + 1) {\n            // Replace the col value in the cell reference with (col - 1)\n            updatedBuffer = updatedBuffer.replace(\n              cellReference,\n              `${this.getColumnName(\n                this.getColumnIndex(colChars) - 1\n              )}${cellRow}`\n            );\n          }\n        }\n      });\n    }\n\n    return updatedBuffer;\n  }\n\n  // returns a 2D array with only the buffers of every cell in the sheet\n  public getData(): string[][] {\n    const output: string[][] = [];\n\n    for (let r = 0; r < this.getNumRows(); r++) {\n      const row: string[] = [];\n      for (let c = 0; c < this.getNumCols(); c++) {\n        row.push(this.sheet[r][c].getBuffer());\n      }\n      output.push(row);\n    }\n\n    return output;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}