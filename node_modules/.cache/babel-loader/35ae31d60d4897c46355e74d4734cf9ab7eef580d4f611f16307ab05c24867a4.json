{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/micha/Documents/mechenko_main/PEDAGOGY/fa23/CS4530/project/team111-project/implementation/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"C:/Users/micha/Documents/mechenko_main/PEDAGOGY/fa23/CS4530/project/team111-project/implementation/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { clone } from '../../../utils/object.js';\nexport function createComplexEigs(_ref) {\n  var addScalar = _ref.addScalar,\n    subtract = _ref.subtract,\n    flatten = _ref.flatten,\n    multiply = _ref.multiply,\n    multiplyScalar = _ref.multiplyScalar,\n    divideScalar = _ref.divideScalar,\n    sqrt = _ref.sqrt,\n    abs = _ref.abs,\n    bignumber = _ref.bignumber,\n    diag = _ref.diag,\n    size = _ref.size,\n    reshape = _ref.reshape,\n    inv = _ref.inv,\n    qr = _ref.qr,\n    usolve = _ref.usolve,\n    usolveAll = _ref.usolveAll,\n    equal = _ref.equal,\n    complex = _ref.complex,\n    larger = _ref.larger,\n    smaller = _ref.smaller,\n    matrixFromColumns = _ref.matrixFromColumns,\n    dot = _ref.dot;\n  /**\n   * @param {number[][]} arr the matrix to find eigenvalues of\n   * @param {number} N size of the matrix\n   * @param {number|BigNumber} prec precision, anything lower will be considered zero\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @param {boolean} findVectors should we find eigenvectors?\n   *\n   * @returns {{ values: number[], vectors: number[][] }}\n   */\n  function complexEigs(arr, N, prec, type) {\n    var findVectors = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    // TODO check if any row/col are zero except the diagonal\n\n    // make sure corresponding rows and columns have similar magnitude\n    // important because of numerical stability\n    // MODIFIES arr by side effect!\n    var R = balance(arr, N, prec, type, findVectors);\n\n    // R is the row transformation matrix\n    // arr = A' = R A R^-1, A is the original matrix\n    // (if findVectors is false, R is undefined)\n    // (And so to return to original matrix: A = R^-1 arr R)\n\n    // TODO if magnitudes of elements vary over many orders,\n    // move greatest elements to the top left corner\n\n    // using similarity transformations, reduce the matrix\n    // to Hessenberg form (upper triangular plus one subdiagonal row)\n    // updates the transformation matrix R with new row operationsq\n    // MODIFIES arr by side effect!\n    reduceToHessenberg(arr, N, prec, type, findVectors, R);\n    // still true that original A = R^-1 arr R)\n\n    // find eigenvalues\n    var _iterateUntilTriangul = iterateUntilTriangular(arr, N, prec, type, findVectors),\n      values = _iterateUntilTriangul.values,\n      C = _iterateUntilTriangul.C;\n\n    // values is the list of eigenvalues, C is the column\n    // transformation matrix that transforms arr, the hessenberg\n    // matrix, to upper triangular\n    // (So U = C^-1 arr C and the relationship between current arr\n    // and original A is unchanged.)\n\n    if (findVectors) {\n      var eigenvectors = findEigenvectors(arr, N, C, R, values, prec, type);\n      return {\n        values: values,\n        eigenvectors: eigenvectors\n      };\n    }\n    return {\n      values: values\n    };\n  }\n\n  /**\n   * @param {number[][]} arr\n   * @param {number} N\n   * @param {number} prec\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {number[][]}\n   */\n  function balance(arr, N, prec, type, findVectors) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var realzero = big ? bignumber(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    var realone = big ? bignumber(1) : 1;\n\n    // base of the floating-point arithmetic\n    var radix = big ? bignumber(10) : 2;\n    var radixSq = multiplyScalar(radix, radix);\n\n    // the diagonal transformation matrix R\n    var Rdiag;\n    if (findVectors) {\n      Rdiag = Array(N).fill(one);\n    }\n\n    // this isn't the only time we loop thru the matrix...\n    var last = false;\n    while (!last) {\n      // ...haha I'm joking! unless...\n      last = true;\n      for (var i = 0; i < N; i++) {\n        // compute the taxicab norm of i-th column and row\n        // TODO optimize for complex numbers\n        var colNorm = realzero;\n        var rowNorm = realzero;\n        for (var j = 0; j < N; j++) {\n          if (i === j) continue;\n          colNorm = addScalar(colNorm, abs(arr[j][i]));\n          rowNorm = addScalar(rowNorm, abs(arr[i][j]));\n        }\n        if (!equal(colNorm, 0) && !equal(rowNorm, 0)) {\n          // find integer power closest to balancing the matrix\n          // (we want to scale only by integer powers of radix,\n          // so that we don't lose any precision due to round-off)\n\n          var f = realone;\n          var c = colNorm;\n          var rowDivRadix = divideScalar(rowNorm, radix);\n          var rowMulRadix = multiplyScalar(rowNorm, radix);\n          while (smaller(c, rowDivRadix)) {\n            c = multiplyScalar(c, radixSq);\n            f = multiplyScalar(f, radix);\n          }\n          while (larger(c, rowMulRadix)) {\n            c = divideScalar(c, radixSq);\n            f = divideScalar(f, radix);\n          }\n\n          // check whether balancing is needed\n          // condition = (c + rowNorm) / f < 0.95 * (colNorm + rowNorm)\n          var condition = smaller(divideScalar(addScalar(c, rowNorm), f), multiplyScalar(addScalar(colNorm, rowNorm), 0.95));\n\n          // apply balancing similarity transformation\n          if (condition) {\n            // we should loop once again to check whether\n            // another rebalancing is needed\n            last = false;\n            var g = divideScalar(1, f);\n            for (var _j = 0; _j < N; _j++) {\n              if (i === _j) {\n                continue;\n              }\n              arr[i][_j] = multiplyScalar(arr[i][_j], g);\n              arr[_j][i] = multiplyScalar(arr[_j][i], f);\n            }\n\n            // keep track of transformations\n            if (findVectors) {\n              Rdiag[i] = multiplyScalar(Rdiag[i], g);\n            }\n          }\n        }\n      }\n    }\n\n    // return the diagonal row transformation matrix\n    return findVectors ? diag(Rdiag) : null;\n  }\n\n  /**\n   * @param {number[][]} arr\n   * @param {number} N\n   * @param {number} prec\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @param {boolean} findVectors\n   * @param {number[][]} R the row transformation matrix that will be modified\n   */\n  function reduceToHessenberg(arr, N, prec, type, findVectors, R) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    if (big) {\n      prec = bignumber(prec);\n    }\n    for (var i = 0; i < N - 2; i++) {\n      // Find the largest subdiag element in the i-th col\n\n      var maxIndex = 0;\n      var max = zero;\n      for (var j = i + 1; j < N; j++) {\n        var el = arr[j][i];\n        if (smaller(abs(max), abs(el))) {\n          max = el;\n          maxIndex = j;\n        }\n      }\n\n      // This col is pivoted, no need to do anything\n      if (smaller(abs(max), prec)) {\n        continue;\n      }\n      if (maxIndex !== i + 1) {\n        // Interchange maxIndex-th and (i+1)-th row\n        var tmp1 = arr[maxIndex];\n        arr[maxIndex] = arr[i + 1];\n        arr[i + 1] = tmp1;\n\n        // Interchange maxIndex-th and (i+1)-th column\n        for (var _j2 = 0; _j2 < N; _j2++) {\n          var tmp2 = arr[_j2][maxIndex];\n          arr[_j2][maxIndex] = arr[_j2][i + 1];\n          arr[_j2][i + 1] = tmp2;\n        }\n\n        // keep track of transformations\n        if (findVectors) {\n          var tmp3 = R[maxIndex];\n          R[maxIndex] = R[i + 1];\n          R[i + 1] = tmp3;\n        }\n      }\n\n      // Reduce following rows and columns\n      for (var _j3 = i + 2; _j3 < N; _j3++) {\n        var n = divideScalar(arr[_j3][i], max);\n        if (n === 0) {\n          continue;\n        }\n\n        // from j-th row subtract n-times (i+1)th row\n        for (var k = 0; k < N; k++) {\n          arr[_j3][k] = subtract(arr[_j3][k], multiplyScalar(n, arr[i + 1][k]));\n        }\n\n        // to (i+1)th column add n-times j-th column\n        for (var _k = 0; _k < N; _k++) {\n          arr[_k][i + 1] = addScalar(arr[_k][i + 1], multiplyScalar(n, arr[_k][_j3]));\n        }\n\n        // keep track of transformations\n        if (findVectors) {\n          for (var _k2 = 0; _k2 < N; _k2++) {\n            R[_j3][_k2] = subtract(R[_j3][_k2], multiplyScalar(n, R[i + 1][_k2]));\n          }\n        }\n      }\n    }\n    return R;\n  }\n\n  /**\n   * @returns {{values: values, C: Matrix}}\n   * @see Press, Wiliams: Numerical recipes in Fortran 77\n   * @see https://en.wikipedia.org/wiki/QR_algorithm\n   */\n  function iterateUntilTriangular(A, N, prec, type, findVectors) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    if (big) {\n      prec = bignumber(prec);\n    }\n\n    // The Francis Algorithm\n    // The core idea of this algorithm is that doing successive\n    // A' = QtAQ transformations will eventually converge to block-\n    // upper-triangular with diagonal blocks either 1x1 or 2x2.\n    // The Q here is the one from the QR decomposition, A = QR.\n    // Since the eigenvalues of a block-upper-triangular matrix are\n    // the eigenvalues of its diagonal blocks and we know how to find\n    // eigenvalues of a 2x2 matrix, we know the eigenvalues of A.\n\n    var arr = clone(A);\n\n    // the list of converged eigenvalues\n    var lambdas = [];\n\n    // size of arr, which will get smaller as eigenvalues converge\n    var n = N;\n\n    // the diagonal of the block-diagonal matrix that turns\n    // converged 2x2 matrices into upper triangular matrices\n    var Sdiag = [];\n\n    // N×N matrix describing the overall transformation done during the QR algorithm\n    var Qtotal = findVectors ? diag(Array(N).fill(one)) : undefined;\n\n    // nxn matrix describing the QR transformations done since last convergence\n    var Qpartial = findVectors ? diag(Array(n).fill(one)) : undefined;\n\n    // last eigenvalue converged before this many steps\n    var lastConvergenceBefore = 0;\n    while (lastConvergenceBefore <= 100) {\n      lastConvergenceBefore += 1;\n\n      // TODO if the convergence is slow, do something clever\n\n      // Perform the factorization\n\n      var k = arr[n - 1][n - 1]; // TODO this is apparently a somewhat\n      // old-fashioned choice; ideally set close to an eigenvalue, or\n      // perhaps better yet switch to the implicit QR version that is sometimes\n      // specifically called the \"Francis algorithm\" that is alluded to\n      // in the following TODO. (Or perhaps we switch to an independently\n      // optimized third-party package for the linear algebra operations...)\n\n      for (var i = 0; i < n; i++) {\n        arr[i][i] = subtract(arr[i][i], k);\n      }\n\n      // TODO do an implicit QR transformation\n      var _qr = qr(arr),\n        Q = _qr.Q,\n        R = _qr.R;\n      arr = multiply(R, Q);\n      for (var _i = 0; _i < n; _i++) {\n        arr[_i][_i] = addScalar(arr[_i][_i], k);\n      }\n\n      // keep track of transformations\n      if (findVectors) {\n        Qpartial = multiply(Qpartial, Q);\n      }\n\n      // The rightmost diagonal element converged to an eigenvalue\n      if (n === 1 || smaller(abs(arr[n - 1][n - 2]), prec)) {\n        lastConvergenceBefore = 0;\n        lambdas.push(arr[n - 1][n - 1]);\n\n        // keep track of transformations\n        if (findVectors) {\n          Sdiag.unshift([[1]]);\n          inflateMatrix(Qpartial, N);\n          Qtotal = multiply(Qtotal, Qpartial);\n          if (n > 1) {\n            Qpartial = diag(Array(n - 1).fill(one));\n          }\n        }\n\n        // reduce the matrix size\n        n -= 1;\n        arr.pop();\n        for (var _i2 = 0; _i2 < n; _i2++) {\n          arr[_i2].pop();\n        }\n\n        // The rightmost diagonal 2x2 block converged\n      } else if (n === 2 || smaller(abs(arr[n - 2][n - 3]), prec)) {\n        lastConvergenceBefore = 0;\n        var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);\n        lambdas.push.apply(lambdas, _toConsumableArray(ll));\n\n        // keep track of transformations\n        if (findVectors) {\n          Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));\n          inflateMatrix(Qpartial, N);\n          Qtotal = multiply(Qtotal, Qpartial);\n          if (n > 2) {\n            Qpartial = diag(Array(n - 2).fill(one));\n          }\n        }\n\n        // reduce the matrix size\n        n -= 2;\n        arr.pop();\n        arr.pop();\n        for (var _i3 = 0; _i3 < n; _i3++) {\n          arr[_i3].pop();\n          arr[_i3].pop();\n        }\n      }\n      if (n === 0) {\n        break;\n      }\n    }\n\n    // standard sorting\n    lambdas.sort(function (a, b) {\n      return +subtract(abs(a), abs(b));\n    });\n\n    // the algorithm didn't converge\n    if (lastConvergenceBefore > 100) {\n      var err = Error('The eigenvalues failed to converge. Only found these eigenvalues: ' + lambdas.join(', '));\n      err.values = lambdas;\n      err.vectors = [];\n      throw err;\n    }\n\n    // combine the overall QR transformation Qtotal with the subsequent\n    // transformation S that turns the diagonal 2x2 blocks to upper triangular\n    var C = findVectors ? multiply(Qtotal, blockDiag(Sdiag, N)) : undefined;\n    return {\n      values: lambdas,\n      C: C\n    };\n  }\n\n  /**\n   * @param {Matrix} A hessenberg-form matrix\n   * @param {number} N size of A\n   * @param {Matrix} C column transformation matrix that turns A into upper triangular\n   * @param {Matrix} R similarity that turns original matrix into A\n   * @param {number[]} values array of eigenvalues of A\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {number[][]} eigenvalues\n   */\n  function findEigenvectors(A, N, C, R, values, prec, type) {\n    var Cinv = inv(C);\n    var U = multiply(Cinv, A, C);\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n\n    // turn values into a kind of \"multiset\"\n    // this way it is easier to find eigenvectors\n    var uniqueValues = [];\n    var multiplicities = [];\n    var _iterator = _createForOfIteratorHelper(values),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var lambda = _step.value;\n        var i = indexOf(uniqueValues, lambda, equal);\n        if (i === -1) {\n          uniqueValues.push(lambda);\n          multiplicities.push(1);\n        } else {\n          multiplicities[i] += 1;\n        }\n      }\n\n      // find eigenvectors by solving U − lambdaE = 0\n      // TODO replace with an iterative eigenvector algorithm\n      // (this one might fail for imprecise eigenvalues)\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var vectors = [];\n    var len = uniqueValues.length;\n    var b = Array(N).fill(zero);\n    var E = diag(Array(N).fill(one));\n    var _loop = function _loop() {\n      var lambda = uniqueValues[_i4];\n      var S = subtract(U, multiply(lambda, E)); // the characteristic matrix\n\n      var solutions = usolveAll(S, b);\n      solutions.shift(); // ignore the null vector\n\n      // looks like we missed something, try inverse iteration\n      // But if that fails, just presume that the original matrix truly\n      // was defective.\n      while (solutions.length < multiplicities[_i4]) {\n        var approxVec = inverseIterate(S, N, solutions, prec, type);\n        if (approxVec === null) {\n          break;\n        } // no more vectors were found\n        solutions.push(approxVec);\n      }\n\n      // Transform back into original array coordinates\n      var correction = multiply(inv(R), C);\n      solutions = solutions.map(function (v) {\n        return multiply(correction, v);\n      });\n      vectors.push.apply(vectors, _toConsumableArray(solutions.map(function (v) {\n        return {\n          value: lambda,\n          vector: flatten(v)\n        };\n      })));\n    };\n    for (var _i4 = 0; _i4 < len; _i4++) {\n      _loop();\n    }\n    return vectors;\n  }\n\n  /**\n   * Compute the eigenvalues of an 2x2 matrix\n   * @return {[number,number]}\n   */\n  function eigenvalues2x2(a, b, c, d) {\n    // lambda_+- = 1/2 trA +- 1/2 sqrt( tr^2 A - 4 detA )\n    var trA = addScalar(a, d);\n    var detA = subtract(multiplyScalar(a, d), multiplyScalar(b, c));\n    var x = multiplyScalar(trA, 0.5);\n    var y = multiplyScalar(sqrt(subtract(multiplyScalar(trA, trA), multiplyScalar(4, detA))), 0.5);\n    return [addScalar(x, y), subtract(x, y)];\n  }\n\n  /**\n   * For an 2x2 matrix compute the transformation matrix S,\n   * so that SAS^-1 is an upper triangular matrix\n   * @return {[[number,number],[number,number]]}\n   * @see https://math.berkeley.edu/~ogus/old/Math_54-05/webfoils/jordan.pdf\n   * @see http://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html\n   */\n  function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n\n    // matrix is already upper triangular\n    // return an identity matrix\n    if (smaller(abs(c), prec)) {\n      return [[one, zero], [zero, one]];\n    }\n\n    // matrix is diagonalizable\n    // return its eigenvectors as columns\n    if (larger(abs(subtract(l1, l2)), prec)) {\n      return [[subtract(l1, d), subtract(l2, d)], [c, c]];\n    }\n\n    // matrix is not diagonalizable\n    // compute diagonal elements of N = A - lambdaI\n    var na = subtract(a, l1);\n    var nd = subtract(d, l1);\n\n    // col(N,2) = 0  implies  S = ( col(N,1), e_1 )\n    // col(N,2) != 0 implies  S = ( col(N,2), e_2 )\n\n    if (smaller(abs(b), prec) && smaller(abs(nd), prec)) {\n      return [[na, one], [c, zero]];\n    } else {\n      return [[b, zero], [nd, one]];\n    }\n  }\n\n  /**\n   * Enlarge the matrix from nxn to NxN, setting the new\n   * elements to 1 on diagonal and 0 elsewhere\n   */\n  function inflateMatrix(arr, N) {\n    // add columns\n    for (var i = 0; i < arr.length; i++) {\n      var _arr$i;\n      (_arr$i = arr[i]).push.apply(_arr$i, _toConsumableArray(Array(N - arr[i].length).fill(0)));\n    }\n\n    // add rows\n    for (var _i5 = arr.length; _i5 < N; _i5++) {\n      arr.push(Array(N).fill(0));\n      arr[_i5][_i5] = 1;\n    }\n    return arr;\n  }\n\n  /**\n   * Create a block-diagonal matrix with the given square matrices on the diagonal\n   * @param {Matrix[] | number[][][]} arr array of matrices to be placed on the diagonal\n   * @param {number} N the size of the resulting matrix\n   */\n  function blockDiag(arr, N) {\n    var M = [];\n    for (var i = 0; i < N; i++) {\n      M[i] = Array(N).fill(0);\n    }\n    var I = 0;\n    var _iterator2 = _createForOfIteratorHelper(arr),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var sub = _step2.value;\n        var n = sub.length;\n        for (var _i6 = 0; _i6 < n; _i6++) {\n          for (var j = 0; j < n; j++) {\n            M[I + _i6][I + j] = sub[_i6][j];\n          }\n        }\n        I += n;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    return M;\n  }\n\n  /**\n   * Finds the index of an element in an array using a custom equality function\n   * @template T\n   * @param {Array<T>} arr array in which to search\n   * @param {T} el the element to find\n   * @param {function(T, T): boolean} fn the equality function, first argument is an element of `arr`, the second is always `el`\n   * @returns {number} the index of `el`, or -1 when it's not in `arr`\n   */\n  function indexOf(arr, el, fn) {\n    for (var i = 0; i < arr.length; i++) {\n      if (fn(arr[i], el)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Provided a near-singular upper-triangular matrix A and a list of vectors,\n   * finds an eigenvector of A with the smallest eigenvalue, which is orthogonal\n   * to each vector in the list\n   * @template T\n   * @param {T[][]} A near-singular square matrix\n   * @param {number} N dimension\n   * @param {T[][]} orthog list of vectors\n   * @param {number} prec epsilon\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @return {T[] | null} eigenvector\n   *\n   * @see Numerical Recipes for Fortran 77 – 11.7 Eigenvalues or Eigenvectors by Inverse Iteration\n   */\n  function inverseIterate(A, N, orthog, prec, type) {\n    var largeNum = type === 'BigNumber' ? bignumber(1000) : 1000;\n    var b; // the vector\n\n    // you better choose a random vector before I count to five\n    var i = 0;\n    for (; i < 5; ++i) {\n      b = randomOrthogonalVector(N, orthog, type);\n      try {\n        b = usolve(A, b);\n      } catch (_unused) {\n        // That direction didn't work, likely because the original matrix\n        // was defective. But still make the full number of tries...\n        continue;\n      }\n      if (larger(norm(b), largeNum)) {\n        break;\n      }\n    }\n    if (i >= 5) {\n      return null; // couldn't find any orthogonal vector in the image\n    }\n\n    // you better converge before I count to ten\n    i = 0;\n    while (true) {\n      var c = usolve(A, b);\n      if (smaller(norm(orthogonalComplement(b, [c])), prec)) {\n        break;\n      }\n      if (++i >= 10) {\n        return null;\n      }\n      b = normalize(c);\n    }\n    return b;\n  }\n\n  /**\n   * Generates a random unit vector of dimension N, orthogonal to each vector in the list\n   * @template T\n   * @param {number} N dimension\n   * @param {T[][]} orthog list of vectors\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {T[]} random vector\n   */\n  function randomOrthogonalVector(N, orthog, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n\n    // generate random vector with the correct type\n    var v = Array(N).fill(0).map(function (_) {\n      return 2 * Math.random() - 1;\n    });\n    if (big) {\n      v = v.map(function (n) {\n        return bignumber(n);\n      });\n    }\n    if (cplx) {\n      v = v.map(function (n) {\n        return complex(n);\n      });\n    }\n\n    // project to orthogonal complement\n    v = orthogonalComplement(v, orthog);\n\n    // normalize\n    return normalize(v, type);\n  }\n\n  /**\n   * Project vector v to the orthogonal complement of an array of vectors\n   */\n  function orthogonalComplement(v, orthog) {\n    var vectorShape = size(v);\n    var _iterator3 = _createForOfIteratorHelper(orthog),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var w = _step3.value;\n        w = reshape(w, vectorShape); // make sure this is just a vector computation\n        // v := v − (w, v)/|w|^2 w\n        v = subtract(v, multiply(divideScalar(dot(w, v), dot(w, w)), w));\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    return v;\n  }\n\n  /**\n   * Calculate the norm of a vector.\n   * We can't use math.norm because factory can't handle circular dependency.\n   * Seriously, I'm really fed up with factory.\n   */\n  function norm(v) {\n    return abs(sqrt(dot(v, v)));\n  }\n\n  /**\n   * Normalize a vector\n   * @template T\n   * @param {T[]} v\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {T[]} normalized vec\n   */\n  function normalize(v, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    return multiply(divideScalar(one, norm(v)), v);\n  }\n  return complexEigs;\n}","map":{"version":3,"names":["clone","createComplexEigs","_ref","addScalar","subtract","flatten","multiply","multiplyScalar","divideScalar","sqrt","abs","bignumber","diag","size","reshape","inv","qr","usolve","usolveAll","equal","complex","larger","smaller","matrixFromColumns","dot","complexEigs","arr","N","prec","type","findVectors","arguments","length","undefined","R","balance","reduceToHessenberg","_iterateUntilTriangul","iterateUntilTriangular","values","C","eigenvectors","findEigenvectors","big","cplx","realzero","one","realone","radix","radixSq","Rdiag","Array","fill","last","i","colNorm","rowNorm","j","f","c","rowDivRadix","rowMulRadix","condition","g","_j","zero","maxIndex","max","el","tmp1","_j2","tmp2","tmp3","_j3","n","k","_k","_k2","A","lambdas","Sdiag","Qtotal","Qpartial","lastConvergenceBefore","_qr","Q","_i","push","unshift","inflateMatrix","pop","_i2","ll","eigenvalues2x2","apply","_toConsumableArray","jordanBase2x2","_i3","sort","a","b","err","Error","join","vectors","blockDiag","Cinv","U","uniqueValues","multiplicities","_iterator","_createForOfIteratorHelper","_step","s","done","lambda","value","indexOf","e","len","E","_loop","_i4","S","solutions","shift","approxVec","inverseIterate","correction","map","v","vector","d","trA","detA","x","y","l1","l2","na","nd","_arr$i","_i5","M","I","_iterator2","_step2","sub","_i6","fn","orthog","largeNum","randomOrthogonalVector","_unused","norm","orthogonalComplement","normalize","_","Math","random","vectorShape","_iterator3","_step3","w"],"sources":["C:/Users/micha/Documents/mechenko_main/PEDAGOGY/fa23/CS4530/project/team111-project/implementation/node_modules/mathjs/lib/esm/function/matrix/eigs/complexEigs.js"],"sourcesContent":["import { clone } from '../../../utils/object.js';\nexport function createComplexEigs(_ref) {\n  var {\n    addScalar,\n    subtract,\n    flatten,\n    multiply,\n    multiplyScalar,\n    divideScalar,\n    sqrt,\n    abs,\n    bignumber,\n    diag,\n    size,\n    reshape,\n    inv,\n    qr,\n    usolve,\n    usolveAll,\n    equal,\n    complex,\n    larger,\n    smaller,\n    matrixFromColumns,\n    dot\n  } = _ref;\n  /**\n   * @param {number[][]} arr the matrix to find eigenvalues of\n   * @param {number} N size of the matrix\n   * @param {number|BigNumber} prec precision, anything lower will be considered zero\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @param {boolean} findVectors should we find eigenvectors?\n   *\n   * @returns {{ values: number[], vectors: number[][] }}\n   */\n  function complexEigs(arr, N, prec, type) {\n    var findVectors = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    // TODO check if any row/col are zero except the diagonal\n\n    // make sure corresponding rows and columns have similar magnitude\n    // important because of numerical stability\n    // MODIFIES arr by side effect!\n    var R = balance(arr, N, prec, type, findVectors);\n\n    // R is the row transformation matrix\n    // arr = A' = R A R^-1, A is the original matrix\n    // (if findVectors is false, R is undefined)\n    // (And so to return to original matrix: A = R^-1 arr R)\n\n    // TODO if magnitudes of elements vary over many orders,\n    // move greatest elements to the top left corner\n\n    // using similarity transformations, reduce the matrix\n    // to Hessenberg form (upper triangular plus one subdiagonal row)\n    // updates the transformation matrix R with new row operationsq\n    // MODIFIES arr by side effect!\n    reduceToHessenberg(arr, N, prec, type, findVectors, R);\n    // still true that original A = R^-1 arr R)\n\n    // find eigenvalues\n    var {\n      values,\n      C\n    } = iterateUntilTriangular(arr, N, prec, type, findVectors);\n\n    // values is the list of eigenvalues, C is the column\n    // transformation matrix that transforms arr, the hessenberg\n    // matrix, to upper triangular\n    // (So U = C^-1 arr C and the relationship between current arr\n    // and original A is unchanged.)\n\n    if (findVectors) {\n      var eigenvectors = findEigenvectors(arr, N, C, R, values, prec, type);\n      return {\n        values,\n        eigenvectors\n      };\n    }\n    return {\n      values\n    };\n  }\n\n  /**\n   * @param {number[][]} arr\n   * @param {number} N\n   * @param {number} prec\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {number[][]}\n   */\n  function balance(arr, N, prec, type, findVectors) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var realzero = big ? bignumber(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    var realone = big ? bignumber(1) : 1;\n\n    // base of the floating-point arithmetic\n    var radix = big ? bignumber(10) : 2;\n    var radixSq = multiplyScalar(radix, radix);\n\n    // the diagonal transformation matrix R\n    var Rdiag;\n    if (findVectors) {\n      Rdiag = Array(N).fill(one);\n    }\n\n    // this isn't the only time we loop thru the matrix...\n    var last = false;\n    while (!last) {\n      // ...haha I'm joking! unless...\n      last = true;\n      for (var i = 0; i < N; i++) {\n        // compute the taxicab norm of i-th column and row\n        // TODO optimize for complex numbers\n        var colNorm = realzero;\n        var rowNorm = realzero;\n        for (var j = 0; j < N; j++) {\n          if (i === j) continue;\n          colNorm = addScalar(colNorm, abs(arr[j][i]));\n          rowNorm = addScalar(rowNorm, abs(arr[i][j]));\n        }\n        if (!equal(colNorm, 0) && !equal(rowNorm, 0)) {\n          // find integer power closest to balancing the matrix\n          // (we want to scale only by integer powers of radix,\n          // so that we don't lose any precision due to round-off)\n\n          var f = realone;\n          var c = colNorm;\n          var rowDivRadix = divideScalar(rowNorm, radix);\n          var rowMulRadix = multiplyScalar(rowNorm, radix);\n          while (smaller(c, rowDivRadix)) {\n            c = multiplyScalar(c, radixSq);\n            f = multiplyScalar(f, radix);\n          }\n          while (larger(c, rowMulRadix)) {\n            c = divideScalar(c, radixSq);\n            f = divideScalar(f, radix);\n          }\n\n          // check whether balancing is needed\n          // condition = (c + rowNorm) / f < 0.95 * (colNorm + rowNorm)\n          var condition = smaller(divideScalar(addScalar(c, rowNorm), f), multiplyScalar(addScalar(colNorm, rowNorm), 0.95));\n\n          // apply balancing similarity transformation\n          if (condition) {\n            // we should loop once again to check whether\n            // another rebalancing is needed\n            last = false;\n            var g = divideScalar(1, f);\n            for (var _j = 0; _j < N; _j++) {\n              if (i === _j) {\n                continue;\n              }\n              arr[i][_j] = multiplyScalar(arr[i][_j], g);\n              arr[_j][i] = multiplyScalar(arr[_j][i], f);\n            }\n\n            // keep track of transformations\n            if (findVectors) {\n              Rdiag[i] = multiplyScalar(Rdiag[i], g);\n            }\n          }\n        }\n      }\n    }\n\n    // return the diagonal row transformation matrix\n    return findVectors ? diag(Rdiag) : null;\n  }\n\n  /**\n   * @param {number[][]} arr\n   * @param {number} N\n   * @param {number} prec\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @param {boolean} findVectors\n   * @param {number[][]} R the row transformation matrix that will be modified\n   */\n  function reduceToHessenberg(arr, N, prec, type, findVectors, R) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    if (big) {\n      prec = bignumber(prec);\n    }\n    for (var i = 0; i < N - 2; i++) {\n      // Find the largest subdiag element in the i-th col\n\n      var maxIndex = 0;\n      var max = zero;\n      for (var j = i + 1; j < N; j++) {\n        var el = arr[j][i];\n        if (smaller(abs(max), abs(el))) {\n          max = el;\n          maxIndex = j;\n        }\n      }\n\n      // This col is pivoted, no need to do anything\n      if (smaller(abs(max), prec)) {\n        continue;\n      }\n      if (maxIndex !== i + 1) {\n        // Interchange maxIndex-th and (i+1)-th row\n        var tmp1 = arr[maxIndex];\n        arr[maxIndex] = arr[i + 1];\n        arr[i + 1] = tmp1;\n\n        // Interchange maxIndex-th and (i+1)-th column\n        for (var _j2 = 0; _j2 < N; _j2++) {\n          var tmp2 = arr[_j2][maxIndex];\n          arr[_j2][maxIndex] = arr[_j2][i + 1];\n          arr[_j2][i + 1] = tmp2;\n        }\n\n        // keep track of transformations\n        if (findVectors) {\n          var tmp3 = R[maxIndex];\n          R[maxIndex] = R[i + 1];\n          R[i + 1] = tmp3;\n        }\n      }\n\n      // Reduce following rows and columns\n      for (var _j3 = i + 2; _j3 < N; _j3++) {\n        var n = divideScalar(arr[_j3][i], max);\n        if (n === 0) {\n          continue;\n        }\n\n        // from j-th row subtract n-times (i+1)th row\n        for (var k = 0; k < N; k++) {\n          arr[_j3][k] = subtract(arr[_j3][k], multiplyScalar(n, arr[i + 1][k]));\n        }\n\n        // to (i+1)th column add n-times j-th column\n        for (var _k = 0; _k < N; _k++) {\n          arr[_k][i + 1] = addScalar(arr[_k][i + 1], multiplyScalar(n, arr[_k][_j3]));\n        }\n\n        // keep track of transformations\n        if (findVectors) {\n          for (var _k2 = 0; _k2 < N; _k2++) {\n            R[_j3][_k2] = subtract(R[_j3][_k2], multiplyScalar(n, R[i + 1][_k2]));\n          }\n        }\n      }\n    }\n    return R;\n  }\n\n  /**\n   * @returns {{values: values, C: Matrix}}\n   * @see Press, Wiliams: Numerical recipes in Fortran 77\n   * @see https://en.wikipedia.org/wiki/QR_algorithm\n   */\n  function iterateUntilTriangular(A, N, prec, type, findVectors) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    if (big) {\n      prec = bignumber(prec);\n    }\n\n    // The Francis Algorithm\n    // The core idea of this algorithm is that doing successive\n    // A' = QtAQ transformations will eventually converge to block-\n    // upper-triangular with diagonal blocks either 1x1 or 2x2.\n    // The Q here is the one from the QR decomposition, A = QR.\n    // Since the eigenvalues of a block-upper-triangular matrix are\n    // the eigenvalues of its diagonal blocks and we know how to find\n    // eigenvalues of a 2x2 matrix, we know the eigenvalues of A.\n\n    var arr = clone(A);\n\n    // the list of converged eigenvalues\n    var lambdas = [];\n\n    // size of arr, which will get smaller as eigenvalues converge\n    var n = N;\n\n    // the diagonal of the block-diagonal matrix that turns\n    // converged 2x2 matrices into upper triangular matrices\n    var Sdiag = [];\n\n    // N×N matrix describing the overall transformation done during the QR algorithm\n    var Qtotal = findVectors ? diag(Array(N).fill(one)) : undefined;\n\n    // nxn matrix describing the QR transformations done since last convergence\n    var Qpartial = findVectors ? diag(Array(n).fill(one)) : undefined;\n\n    // last eigenvalue converged before this many steps\n    var lastConvergenceBefore = 0;\n    while (lastConvergenceBefore <= 100) {\n      lastConvergenceBefore += 1;\n\n      // TODO if the convergence is slow, do something clever\n\n      // Perform the factorization\n\n      var k = arr[n - 1][n - 1]; // TODO this is apparently a somewhat\n      // old-fashioned choice; ideally set close to an eigenvalue, or\n      // perhaps better yet switch to the implicit QR version that is sometimes\n      // specifically called the \"Francis algorithm\" that is alluded to\n      // in the following TODO. (Or perhaps we switch to an independently\n      // optimized third-party package for the linear algebra operations...)\n\n      for (var i = 0; i < n; i++) {\n        arr[i][i] = subtract(arr[i][i], k);\n      }\n\n      // TODO do an implicit QR transformation\n      var {\n        Q,\n        R\n      } = qr(arr);\n      arr = multiply(R, Q);\n      for (var _i = 0; _i < n; _i++) {\n        arr[_i][_i] = addScalar(arr[_i][_i], k);\n      }\n\n      // keep track of transformations\n      if (findVectors) {\n        Qpartial = multiply(Qpartial, Q);\n      }\n\n      // The rightmost diagonal element converged to an eigenvalue\n      if (n === 1 || smaller(abs(arr[n - 1][n - 2]), prec)) {\n        lastConvergenceBefore = 0;\n        lambdas.push(arr[n - 1][n - 1]);\n\n        // keep track of transformations\n        if (findVectors) {\n          Sdiag.unshift([[1]]);\n          inflateMatrix(Qpartial, N);\n          Qtotal = multiply(Qtotal, Qpartial);\n          if (n > 1) {\n            Qpartial = diag(Array(n - 1).fill(one));\n          }\n        }\n\n        // reduce the matrix size\n        n -= 1;\n        arr.pop();\n        for (var _i2 = 0; _i2 < n; _i2++) {\n          arr[_i2].pop();\n        }\n\n        // The rightmost diagonal 2x2 block converged\n      } else if (n === 2 || smaller(abs(arr[n - 2][n - 3]), prec)) {\n        lastConvergenceBefore = 0;\n        var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);\n        lambdas.push(...ll);\n\n        // keep track of transformations\n        if (findVectors) {\n          Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));\n          inflateMatrix(Qpartial, N);\n          Qtotal = multiply(Qtotal, Qpartial);\n          if (n > 2) {\n            Qpartial = diag(Array(n - 2).fill(one));\n          }\n        }\n\n        // reduce the matrix size\n        n -= 2;\n        arr.pop();\n        arr.pop();\n        for (var _i3 = 0; _i3 < n; _i3++) {\n          arr[_i3].pop();\n          arr[_i3].pop();\n        }\n      }\n      if (n === 0) {\n        break;\n      }\n    }\n\n    // standard sorting\n    lambdas.sort((a, b) => +subtract(abs(a), abs(b)));\n\n    // the algorithm didn't converge\n    if (lastConvergenceBefore > 100) {\n      var err = Error('The eigenvalues failed to converge. Only found these eigenvalues: ' + lambdas.join(', '));\n      err.values = lambdas;\n      err.vectors = [];\n      throw err;\n    }\n\n    // combine the overall QR transformation Qtotal with the subsequent\n    // transformation S that turns the diagonal 2x2 blocks to upper triangular\n    var C = findVectors ? multiply(Qtotal, blockDiag(Sdiag, N)) : undefined;\n    return {\n      values: lambdas,\n      C\n    };\n  }\n\n  /**\n   * @param {Matrix} A hessenberg-form matrix\n   * @param {number} N size of A\n   * @param {Matrix} C column transformation matrix that turns A into upper triangular\n   * @param {Matrix} R similarity that turns original matrix into A\n   * @param {number[]} values array of eigenvalues of A\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {number[][]} eigenvalues\n   */\n  function findEigenvectors(A, N, C, R, values, prec, type) {\n    var Cinv = inv(C);\n    var U = multiply(Cinv, A, C);\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n\n    // turn values into a kind of \"multiset\"\n    // this way it is easier to find eigenvectors\n    var uniqueValues = [];\n    var multiplicities = [];\n    for (var lambda of values) {\n      var i = indexOf(uniqueValues, lambda, equal);\n      if (i === -1) {\n        uniqueValues.push(lambda);\n        multiplicities.push(1);\n      } else {\n        multiplicities[i] += 1;\n      }\n    }\n\n    // find eigenvectors by solving U − lambdaE = 0\n    // TODO replace with an iterative eigenvector algorithm\n    // (this one might fail for imprecise eigenvalues)\n\n    var vectors = [];\n    var len = uniqueValues.length;\n    var b = Array(N).fill(zero);\n    var E = diag(Array(N).fill(one));\n    var _loop = function _loop() {\n      var lambda = uniqueValues[_i4];\n      var S = subtract(U, multiply(lambda, E)); // the characteristic matrix\n\n      var solutions = usolveAll(S, b);\n      solutions.shift(); // ignore the null vector\n\n      // looks like we missed something, try inverse iteration\n      // But if that fails, just presume that the original matrix truly\n      // was defective.\n      while (solutions.length < multiplicities[_i4]) {\n        var approxVec = inverseIterate(S, N, solutions, prec, type);\n        if (approxVec === null) {\n          break;\n        } // no more vectors were found\n        solutions.push(approxVec);\n      }\n\n      // Transform back into original array coordinates\n      var correction = multiply(inv(R), C);\n      solutions = solutions.map(v => multiply(correction, v));\n      vectors.push(...solutions.map(v => ({\n        value: lambda,\n        vector: flatten(v)\n      })));\n    };\n    for (var _i4 = 0; _i4 < len; _i4++) {\n      _loop();\n    }\n    return vectors;\n  }\n\n  /**\n   * Compute the eigenvalues of an 2x2 matrix\n   * @return {[number,number]}\n   */\n  function eigenvalues2x2(a, b, c, d) {\n    // lambda_+- = 1/2 trA +- 1/2 sqrt( tr^2 A - 4 detA )\n    var trA = addScalar(a, d);\n    var detA = subtract(multiplyScalar(a, d), multiplyScalar(b, c));\n    var x = multiplyScalar(trA, 0.5);\n    var y = multiplyScalar(sqrt(subtract(multiplyScalar(trA, trA), multiplyScalar(4, detA))), 0.5);\n    return [addScalar(x, y), subtract(x, y)];\n  }\n\n  /**\n   * For an 2x2 matrix compute the transformation matrix S,\n   * so that SAS^-1 is an upper triangular matrix\n   * @return {[[number,number],[number,number]]}\n   * @see https://math.berkeley.edu/~ogus/old/Math_54-05/webfoils/jordan.pdf\n   * @see http://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html\n   */\n  function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var zero = big ? bignumber(0) : cplx ? complex(0) : 0;\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n\n    // matrix is already upper triangular\n    // return an identity matrix\n    if (smaller(abs(c), prec)) {\n      return [[one, zero], [zero, one]];\n    }\n\n    // matrix is diagonalizable\n    // return its eigenvectors as columns\n    if (larger(abs(subtract(l1, l2)), prec)) {\n      return [[subtract(l1, d), subtract(l2, d)], [c, c]];\n    }\n\n    // matrix is not diagonalizable\n    // compute diagonal elements of N = A - lambdaI\n    var na = subtract(a, l1);\n    var nd = subtract(d, l1);\n\n    // col(N,2) = 0  implies  S = ( col(N,1), e_1 )\n    // col(N,2) != 0 implies  S = ( col(N,2), e_2 )\n\n    if (smaller(abs(b), prec) && smaller(abs(nd), prec)) {\n      return [[na, one], [c, zero]];\n    } else {\n      return [[b, zero], [nd, one]];\n    }\n  }\n\n  /**\n   * Enlarge the matrix from nxn to NxN, setting the new\n   * elements to 1 on diagonal and 0 elsewhere\n   */\n  function inflateMatrix(arr, N) {\n    // add columns\n    for (var i = 0; i < arr.length; i++) {\n      arr[i].push(...Array(N - arr[i].length).fill(0));\n    }\n\n    // add rows\n    for (var _i5 = arr.length; _i5 < N; _i5++) {\n      arr.push(Array(N).fill(0));\n      arr[_i5][_i5] = 1;\n    }\n    return arr;\n  }\n\n  /**\n   * Create a block-diagonal matrix with the given square matrices on the diagonal\n   * @param {Matrix[] | number[][][]} arr array of matrices to be placed on the diagonal\n   * @param {number} N the size of the resulting matrix\n   */\n  function blockDiag(arr, N) {\n    var M = [];\n    for (var i = 0; i < N; i++) {\n      M[i] = Array(N).fill(0);\n    }\n    var I = 0;\n    for (var sub of arr) {\n      var n = sub.length;\n      for (var _i6 = 0; _i6 < n; _i6++) {\n        for (var j = 0; j < n; j++) {\n          M[I + _i6][I + j] = sub[_i6][j];\n        }\n      }\n      I += n;\n    }\n    return M;\n  }\n\n  /**\n   * Finds the index of an element in an array using a custom equality function\n   * @template T\n   * @param {Array<T>} arr array in which to search\n   * @param {T} el the element to find\n   * @param {function(T, T): boolean} fn the equality function, first argument is an element of `arr`, the second is always `el`\n   * @returns {number} the index of `el`, or -1 when it's not in `arr`\n   */\n  function indexOf(arr, el, fn) {\n    for (var i = 0; i < arr.length; i++) {\n      if (fn(arr[i], el)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Provided a near-singular upper-triangular matrix A and a list of vectors,\n   * finds an eigenvector of A with the smallest eigenvalue, which is orthogonal\n   * to each vector in the list\n   * @template T\n   * @param {T[][]} A near-singular square matrix\n   * @param {number} N dimension\n   * @param {T[][]} orthog list of vectors\n   * @param {number} prec epsilon\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @return {T[] | null} eigenvector\n   *\n   * @see Numerical Recipes for Fortran 77 – 11.7 Eigenvalues or Eigenvectors by Inverse Iteration\n   */\n  function inverseIterate(A, N, orthog, prec, type) {\n    var largeNum = type === 'BigNumber' ? bignumber(1000) : 1000;\n    var b; // the vector\n\n    // you better choose a random vector before I count to five\n    var i = 0;\n    for (; i < 5; ++i) {\n      b = randomOrthogonalVector(N, orthog, type);\n      try {\n        b = usolve(A, b);\n      } catch (_unused) {\n        // That direction didn't work, likely because the original matrix\n        // was defective. But still make the full number of tries...\n        continue;\n      }\n      if (larger(norm(b), largeNum)) {\n        break;\n      }\n    }\n    if (i >= 5) {\n      return null; // couldn't find any orthogonal vector in the image\n    }\n\n    // you better converge before I count to ten\n    i = 0;\n    while (true) {\n      var c = usolve(A, b);\n      if (smaller(norm(orthogonalComplement(b, [c])), prec)) {\n        break;\n      }\n      if (++i >= 10) {\n        return null;\n      }\n      b = normalize(c);\n    }\n    return b;\n  }\n\n  /**\n   * Generates a random unit vector of dimension N, orthogonal to each vector in the list\n   * @template T\n   * @param {number} N dimension\n   * @param {T[][]} orthog list of vectors\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {T[]} random vector\n   */\n  function randomOrthogonalVector(N, orthog, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n\n    // generate random vector with the correct type\n    var v = Array(N).fill(0).map(_ => 2 * Math.random() - 1);\n    if (big) {\n      v = v.map(n => bignumber(n));\n    }\n    if (cplx) {\n      v = v.map(n => complex(n));\n    }\n\n    // project to orthogonal complement\n    v = orthogonalComplement(v, orthog);\n\n    // normalize\n    return normalize(v, type);\n  }\n\n  /**\n   * Project vector v to the orthogonal complement of an array of vectors\n   */\n  function orthogonalComplement(v, orthog) {\n    var vectorShape = size(v);\n    for (var w of orthog) {\n      w = reshape(w, vectorShape); // make sure this is just a vector computation\n      // v := v − (w, v)/|w|^2 w\n      v = subtract(v, multiply(divideScalar(dot(w, v), dot(w, w)), w));\n    }\n    return v;\n  }\n\n  /**\n   * Calculate the norm of a vector.\n   * We can't use math.norm because factory can't handle circular dependency.\n   * Seriously, I'm really fed up with factory.\n   */\n  function norm(v) {\n    return abs(sqrt(dot(v, v)));\n  }\n\n  /**\n   * Normalize a vector\n   * @template T\n   * @param {T[]} v\n   * @param {'number'|'BigNumber'|'Complex'} type\n   * @returns {T[]} normalized vec\n   */\n  function normalize(v, type) {\n    var big = type === 'BigNumber';\n    var cplx = type === 'Complex';\n    var one = big ? bignumber(1) : cplx ? complex(1) : 1;\n    return multiply(divideScalar(one, norm(v)), v);\n  }\n  return complexEigs;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}