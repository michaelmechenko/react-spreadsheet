{"ast":null,"code":"import { Expressions } from \"../../expressions/expression-enums.model\";\nimport { SpreadsheetCellModel } from \"./cells/spreadsheet-cell.model\";\nexport class SpreadSheetPageModel {\n  constructor(name, nArray) {\n    this._sheetName = void 0;\n    this.sheet = void 0;\n    this.selectedCell = void 0;\n    this._sheetName = name;\n    this.sheet = [];\n    if (nArray !== undefined && nArray > 0) {\n      for (let r = 0; r < nArray; r++) {\n        this.sheet[r] = [];\n        for (let c = 0; c < nArray; c++) {\n          this.sheet[r][c] = new SpreadsheetCellModel();\n        }\n      }\n    } else {\n      for (let r = 0; r < 15; r++) {\n        this.sheet[r] = [];\n        for (let c = 0; c < 15; c++) {\n          this.sheet[r][c] = new SpreadsheetCellModel();\n        }\n      }\n    }\n    this.selectedCell = this.sheet[1][1];\n  }\n  get sheetName() {\n    return this._sheetName;\n  }\n\n  // find workaround\n  getSheet() {\n    return this.sheet;\n  }\n\n  // find workaround\n  getCellAt(row, col) {\n    return this.sheet[row][col];\n  }\n  getSelectedCell() {\n    return this.selectedCell;\n  }\n  setSelectedCell(cell) {\n    cell.setIsSelected(true);\n    this.selectedCell = cell;\n  }\n  getSelectedCellReference() {\n    return this.selectedCell.getReference();\n  }\n  getValueAtCell(cellReference) {\n    const cell = this.getCellFromReference(cellReference);\n    return cell.getDisplay();\n  }\n  setValue(cellReference, value) {\n    const cell = this.getCellFromReference(cellReference);\n    let expression = \"\";\n    if (value.startsWith(\"=\", 0)) {\n      try {\n        expression = this.evaluateExpression(value.substring(1));\n        cell.setBuffer(value, expression);\n      } catch (error) {\n        throw new Error(`Invalid Expression ${error}`);\n      }\n    } else {\n      cell.setBuffer(value);\n    }\n  }\n  getCellFromReference(cellReference) {\n    // NEED TO CHECK THAT INPUT IS VALID\n    const colChar = cellReference.charAt(0).toUpperCase();\n    const col = colChar.charCodeAt(0) - 64;\n    const row = parseInt(cellReference.substring(1));\n    return this.sheet[row][col];\n  }\n  addRow(index) {\n    if (index < 0 || index > this.sheet.length) {\n      throw new Error(\"Invalid row index\");\n    }\n    const newRow = [];\n    for (let col = 0; col < this.sheet[0].length; col++) {\n      newRow[col] = new SpreadsheetCellModel();\n    }\n    this.sheet.splice(index, 0, newRow);\n  }\n  addColumn(index) {\n    if (index < 0 || index > this.sheet[0].length) {\n      throw new Error(\"Invalid column index\");\n    }\n    for (let row = 0; row < this.sheet.length; row++) {\n      this.sheet[row].splice(index, 0, new SpreadsheetCellModel());\n    }\n  }\n  removeRow(index) {\n    if (index < 0 || index >= this.sheet.length) {\n      throw new Error(\"Invalid row index\");\n    }\n    this.sheet.splice(index, 1);\n  }\n  removeColumn(index) {\n    if (index < 0 || index >= this.sheet[0].length) {\n      throw new Error(\"Invalid column index\");\n    }\n    for (let row = 0; row < this.sheet.length; row++) {\n      this.sheet[row].splice(index, 1);\n    }\n  }\n  getNrRows() {\n    return this.sheet.length;\n  }\n  getNrCols() {\n    return this.sheet[0].length;\n  }\n  evaluateExpression(input) {\n    try {\n      while (input.includes(Expressions.REF)) {\n        input = this.evaluateRefExpressions(input);\n      }\n      while (input.includes(Expressions.SUM)) {\n        input = this.evaluateSumExpressions(input);\n      }\n      while (input.includes(Expressions.AVG)) {\n        input = this.evaluateAvgExpressions(input);\n      }\n      return input;\n    } catch (error) {\n      throw new Error(`Failed to replace expressions ${error}`);\n    }\n  }\n  evaluateRefExpressions(input) {\n    const refRegex = /REF\\(([^)]+)\\)/g;\n    return input.replace(refRegex, (_, cellReference) => this.getCellFromReference(cellReference).getDisplay());\n  }\n  evaluateSumExpressions(input) {\n    const sumRegex = /SUM\\(([^)]+)\\)/g;\n    return input.replace(sumRegex, (_, range) => this.sumCells(range));\n  }\n  evaluateAvgExpressions(input) {\n    const avgRegex = /AVG\\(([^)]+)\\)/g;\n    return input.replace(avgRegex, (_, range) => this.averageCells(range));\n  }\n\n  //TODO\n  sumCells(range) {\n    let sum = 0;\n    let cellRange = [];\n    if (range.match(\"^[^:]+:[^:]+$\")) {\n      // regex to match expressions using colon for cell range\n      const [startCell, endCell] = range.split(\":\");\n      cellRange = this.getRangeOfCells(startCell, endCell);\n    } else if (range.match(\"^[A-Za-z]\\\\d+(,\\\\s?[A-Za-z]\\\\d+)*$\")) {\n      // regex to match expressions using comma\n      cellRange = range.split(\",\");\n    } else {\n      throw new Error(`Syntax for reference is not correct. ${range}`);\n    }\n    for (let cell of cellRange) {\n      let cellVal = Number(this.getCellFromReference(cell).getDisplay());\n      if (Number.isNaN(cellVal)) {\n        throw new Error(\"Cell is not a Number\");\n      } else {\n        sum += cellVal;\n      }\n    }\n    return sum.toString();\n  }\n  averageCells(range) {\n    let sum = 0;\n    let cellRange = [];\n    if (range.match(\"^[^:]+:[^:]+$\")) {\n      // regex to match expressions using colon for cell range\n      const [startCell, endCell] = range.split(\":\");\n      cellRange = this.getRangeOfCells(startCell, endCell);\n    } else if (range.match(\"^[A-Za-z]\\\\d+(,\\\\s?[A-Za-z]\\\\d+)*$\")) {\n      // regex to match expressions using comma\n      cellRange = range.split(\",\");\n    } else {\n      throw new Error(`Syntax for reference is not correct. ${range}`);\n    }\n    let count = cellRange.length;\n    for (let cell of cellRange) {\n      let cellVal = Number(this.getCellFromReference(cell).getDisplay());\n      if (Number.isNaN(cellVal)) {\n        throw new Error(\"Cell is not a Number\");\n      } else {\n        sum += cellVal;\n      }\n    }\n    let average = sum / count;\n    return average.toString();\n  }\n  getRangeOfCells(startCell, endCell) {\n    let cells = [];\n    const [startCol, startRow] = startCell.split(\"\");\n    const [endCol, endRow] = endCell.split(\"\");\n    const startColIdx = startCol.charCodeAt(0) - \"A\".charCodeAt(0);\n    const endColIdx = endCol.charCodeAt(0) - \"A\".charCodeAt(0);\n    const startRowIdx = Number(startRow);\n    const endRowIdx = Number(endRow);\n    for (let i = startRowIdx; i <= endRowIdx; i++) {\n      for (let j = startColIdx; j <= endColIdx; j++) {\n        cells.push(this.getColumnName(j) + i);\n      }\n    }\n    return cells;\n  }\n  getColumnName(columnNumber) {\n    return String.fromCharCode(columnNumber + 65);\n  }\n}","map":{"version":3,"names":["Expressions","SpreadsheetCellModel","SpreadSheetPageModel","constructor","name","nArray","_sheetName","sheet","selectedCell","undefined","r","c","sheetName","getSheet","getCellAt","row","col","getSelectedCell","setSelectedCell","cell","setIsSelected","getSelectedCellReference","getReference","getValueAtCell","cellReference","getCellFromReference","getDisplay","setValue","value","expression","startsWith","evaluateExpression","substring","setBuffer","error","Error","colChar","charAt","toUpperCase","charCodeAt","parseInt","addRow","index","length","newRow","splice","addColumn","removeRow","removeColumn","getNrRows","getNrCols","input","includes","REF","evaluateRefExpressions","SUM","evaluateSumExpressions","AVG","evaluateAvgExpressions","refRegex","replace","_","sumRegex","range","sumCells","avgRegex","averageCells","sum","cellRange","match","startCell","endCell","split","getRangeOfCells","cellVal","Number","isNaN","toString","count","average","cells","startCol","startRow","endCol","endRow","startColIdx","endColIdx","startRowIdx","endRowIdx","i","j","push","getColumnName","columnNumber","String","fromCharCode"],"sources":["C:/Users/micha/Documents/mechenko_main/PEDAGOGY/fa23/CS4530/project/team111-project/implementation/src/model/domain/spreadsheet-page.model.ts"],"sourcesContent":["import { Expressions } from \"../../expressions/expression-enums.model\";\nimport { ISpreadsheetPage } from \"../interfaces/spreadsheet-page.interface\";\nimport { SpreadsheetCellModel } from \"./cells/spreadsheet-cell.model\";\n\nexport class SpreadSheetPageModel implements ISpreadsheetPage {\n  private _sheetName: string;\n  private sheet: SpreadsheetCellModel[][];\n  private selectedCell: SpreadsheetCellModel;\n\n  public constructor(name: string, nArray?: number) {\n    this._sheetName = name;\n    this.sheet = [];\n\n    if (nArray !== undefined && nArray > 0) {\n      for (let r: number = 0; r < nArray; r++) {\n        this.sheet[r] = [];\n        for (let c: number = 0; c < nArray; c++) {\n          this.sheet[r][c] = new SpreadsheetCellModel();\n        }\n      }\n    } else {\n      for (let r: number = 0; r < 15; r++) {\n        this.sheet[r] = [];\n        for (let c: number = 0; c < 15; c++) {\n          this.sheet[r][c] = new SpreadsheetCellModel();\n        }\n      }\n    }\n    this.selectedCell = this.sheet[1][1];\n  }\n\n  public get sheetName(): string {\n    return this._sheetName;\n  }\n\n  // find workaround\n  public getSheet(): SpreadsheetCellModel[][] {\n    return this.sheet;\n  }\n\n  // find workaround\n  public getCellAt(row: number, col: number): SpreadsheetCellModel {\n    return this.sheet[row][col];\n  }\n\n  public getSelectedCell(): SpreadsheetCellModel {\n    return this.selectedCell;\n  }\n\n  public setSelectedCell(cell: SpreadsheetCellModel): void {\n    cell.setIsSelected(true);\n    this.selectedCell = cell;\n  }\n\n  public getSelectedCellReference(): string {\n    return this.selectedCell.getReference();\n  }\n\n  public getValueAtCell(cellReference: string): string {\n    const cell = this.getCellFromReference(cellReference);\n    return cell.getDisplay();\n  }\n\n  public setValue(cellReference: string, value: string): void {\n    const cell = this.getCellFromReference(cellReference);\n    let expression = \"\";\n    if (value.startsWith(\"=\", 0)) {\n      try {\n        expression = this.evaluateExpression(value.substring(1));\n        cell.setBuffer(value, expression);\n      } catch (error) {\n        throw new Error(`Invalid Expression ${error}`);\n      }\n    } else {\n      cell.setBuffer(value);\n    }\n  }\n\n  public getCellFromReference(cellReference: string): SpreadsheetCellModel {\n    // NEED TO CHECK THAT INPUT IS VALID\n    const colChar = cellReference.charAt(0).toUpperCase();\n    const col = colChar.charCodeAt(0) - 64;\n    const row = parseInt(cellReference.substring(1));\n\n    return this.sheet[row][col];\n  }\n\n  public addRow(index: number): void {\n    if (index < 0 || index > this.sheet.length) {\n      throw new Error(\"Invalid row index\");\n    }\n\n    const newRow: SpreadsheetCellModel[] = [];\n    for (let col = 0; col < this.sheet[0].length; col++) {\n      newRow[col] = new SpreadsheetCellModel();\n    }\n\n    this.sheet.splice(index, 0, newRow);\n  }\n\n  public addColumn(index: number): void {\n    if (index < 0 || index > this.sheet[0].length) {\n      throw new Error(\"Invalid column index\");\n    }\n\n    for (let row = 0; row < this.sheet.length; row++) {\n      this.sheet[row].splice(index, 0, new SpreadsheetCellModel());\n    }\n  }\n\n  public removeRow(index: number): void {\n    if (index < 0 || index >= this.sheet.length) {\n      throw new Error(\"Invalid row index\");\n    }\n\n    this.sheet.splice(index, 1);\n  }\n\n  public removeColumn(index: number): void {\n    if (index < 0 || index >= this.sheet[0].length) {\n      throw new Error(\"Invalid column index\");\n    }\n\n    for (let row = 0; row < this.sheet.length; row++) {\n      this.sheet[row].splice(index, 1);\n    }\n  }\n\n  public getNrRows(): number {\n    return this.sheet.length;\n  }\n  public getNrCols(): number {\n    return this.sheet[0].length;\n  }\n\n  private evaluateExpression(input: string): string {\n    try {\n      while (input.includes(Expressions.REF)) {\n        input = this.evaluateRefExpressions(input);\n      }\n\n      while (input.includes(Expressions.SUM)) {\n        input = this.evaluateSumExpressions(input);\n      }\n\n      while (input.includes(Expressions.AVG)) {\n        input = this.evaluateAvgExpressions(input);\n      }\n\n      return input;\n    } catch (error) {\n      throw new Error(`Failed to replace expressions ${error}`);\n    }\n  }\n\n  private evaluateRefExpressions(input: string): string {\n    const refRegex = /REF\\(([^)]+)\\)/g;\n    return input.replace(refRegex, (_, cellReference) =>\n      this.getCellFromReference(cellReference).getDisplay()\n    );\n  }\n\n  private evaluateSumExpressions(input: string): string {\n    const sumRegex = /SUM\\(([^)]+)\\)/g;\n    return input.replace(sumRegex, (_, range) => this.sumCells(range));\n  }\n\n  private evaluateAvgExpressions(input: string): string {\n    const avgRegex = /AVG\\(([^)]+)\\)/g;\n    return input.replace(avgRegex, (_, range) => this.averageCells(range));\n  }\n\n  //TODO\n  private sumCells(range: string): string {\n    let sum: number = 0;\n    let cellRange = [];\n\n    if (range.match(\"^[^:]+:[^:]+$\")) {\n      // regex to match expressions using colon for cell range\n      const [startCell, endCell] = range.split(\":\");\n      cellRange = this.getRangeOfCells(startCell, endCell);\n    } else if (range.match(\"^[A-Za-z]\\\\d+(,\\\\s?[A-Za-z]\\\\d+)*$\")) {\n      // regex to match expressions using comma\n      cellRange = range.split(\",\");\n    } else {\n      throw new Error(`Syntax for reference is not correct. ${range}`);\n    }\n\n    for (let cell of cellRange) {\n      let cellVal = Number(this.getCellFromReference(cell).getDisplay());\n      if (Number.isNaN(cellVal)) {\n        throw new Error(\"Cell is not a Number\");\n      } else {\n        sum += cellVal;\n      }\n    }\n\n    return sum.toString();\n  }\n\n  private averageCells(range: string): string {\n    let sum: number = 0;\n    let cellRange = [];\n\n    if (range.match(\"^[^:]+:[^:]+$\")) {\n      // regex to match expressions using colon for cell range\n      const [startCell, endCell] = range.split(\":\");\n      cellRange = this.getRangeOfCells(startCell, endCell);\n    } else if (range.match(\"^[A-Za-z]\\\\d+(,\\\\s?[A-Za-z]\\\\d+)*$\")) {\n      // regex to match expressions using comma\n      cellRange = range.split(\",\");\n    } else {\n      throw new Error(`Syntax for reference is not correct. ${range}`);\n    }\n\n    let count = cellRange.length;\n\n    for (let cell of cellRange) {\n      let cellVal = Number(this.getCellFromReference(cell).getDisplay());\n      if (Number.isNaN(cellVal)) {\n        throw new Error(\"Cell is not a Number\");\n      } else {\n        sum += cellVal;\n      }\n    }\n\n    let average = sum / count;\n    return average.toString();\n  }\n\n  private getRangeOfCells(startCell: string, endCell: string): string[] {\n    let cells: string[] = [];\n    const [startCol, startRow] = startCell.split(\"\");\n    const [endCol, endRow] = endCell.split(\"\");\n\n    const startColIdx = startCol.charCodeAt(0) - \"A\".charCodeAt(0);\n    const endColIdx = endCol.charCodeAt(0) - \"A\".charCodeAt(0);\n    const startRowIdx = Number(startRow);\n    const endRowIdx = Number(endRow);\n\n    for (let i = startRowIdx; i <= endRowIdx; i++) {\n      for (let j = startColIdx; j <= endColIdx; j++) {\n        cells.push(this.getColumnName(j) + i);\n      }\n    }\n\n    return cells;\n  }\n\n  private getColumnName(columnNumber: number): string {\n    return String.fromCharCode(columnNumber + 65);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}